<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Super Hiko — vs. Friends</title>
  <style>
    :root{
      --bg:#070b14;
      --line: rgba(255,255,255,.14);
      --text:#eaf0ff;
      --muted: rgba(255,255,255,.78);
    }
    html, body { height:100%; margin:0; color:var(--text); font-family: system-ui, Arial; }
    body{
      background: radial-gradient(1200px 600px at 50% 0%, #0f1a3a 0%, #070b14 55%);
    }
    .wrap{ display:flex; flex-direction:column; align-items:center; gap:10px; padding:12px; }

    /* START */
    .start{
      width:min(980px, 96vw);
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(22,32,62,.92), rgba(10,14,30,.92));
      border-radius:18px;
      box-shadow: 0 16px 45px rgba(0,0,0,.45);
      padding:16px;
      position:relative;
      overflow:hidden;
    }
    .start:before{
      content:"";
      position:absolute; inset:-60px;
      background:
        radial-gradient(220px 220px at 20% 15%, rgba(80,180,120,.18), transparent 60%),
        radial-gradient(260px 260px at 80% 25%, rgba(70,120,220,.20), transparent 62%),
        radial-gradient(260px 260px at 50% 100%, rgba(220,80,170,.14), transparent 62%);
      pointer-events:none;
    }
    .row{ position:relative; display:flex; gap:12px; justify-content:space-between; align-items:flex-start; flex-wrap:wrap; }
    .logo{ display:flex; align-items:center; gap:10px; }
    .badge{
      width:44px; height:44px; border-radius:14px;
      background: linear-gradient(135deg, rgba(80,180,120,.95), rgba(70,120,220,.95));
      box-shadow: 0 10px 25px rgba(0,0,0,.35);
      display:grid; place-items:center;
      font-weight:1000;
    }
    .title{ margin:0; font-weight:1000; font-size:28px; letter-spacing:.3px; }
    .sub{ margin:0; opacity:.9; font-weight:700; font-size:13px; }

    .help{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      border-radius:14px;
      padding:10px 12px;
      font-size:13px;
      line-height:1.35;
      color:var(--muted);
      max-width: 420px;
    }
    .help b{ color:var(--text); }

    .list{
      position:relative;
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap:9px;
      margin: 12px 0 14px;
    }
    .card{
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      padding:10px 12px;
      box-shadow: 0 10px 18px rgba(0,0,0,.18);
      position:relative;
      overflow:hidden;
      font-weight:900;
    }
    .card small{ display:block; margin-top:3px; font-weight:700; opacity:.9; font-size:12px; }

    .go{
      display:block; width:100%;
      font-weight:1000; font-size:18px;
      padding:14px 16px; border-radius:16px;
      cursor:pointer;
      border:1px solid rgba(255,255,255,.22);
      background: linear-gradient(135deg, rgba(80,180,120,.95), rgba(70,120,220,.95));
      color:#fff;
      box-shadow: 0 14px 30px rgba(0,0,0,.35);
    }
    .note{ margin:10px 0 0; font-size:12px; opacity:.75; position:relative; }

    /* HUD */
    .hud{
      width:min(980px, 96vw);
      display:flex; justify-content:space-between; align-items:center;
      font-size:13px; opacity:.98;
      gap:10px;
      user-select:none;
      -webkit-user-select:none;
    }
    button{
      background:#0f1834; color:#eaf0ff;
      border:1px solid rgba(255,255,255,.15);
      padding:8px 10px; border-radius:12px; cursor:pointer;
    }
    .hidden{ display:none !important; }

    /* Canvas */
    .stage{
      width:min(980px, 96vw);
      position:relative;
      display:flex;
      justify-content:center;
      align-items:center;
      touch-action:none;
    }
    canvas{
      width:100%;
      height:auto;
      border-radius:16px;
      box-shadow: 0 16px 45px rgba(0,0,0,.45);
      background: linear-gradient(#6bb6ff, #bfe6ff 55%, #7bdc6f 55%, #49b85a);
      image-rendering: pixelated;
      display:none;
    }

    /* Mobile hint */
    .touchHint{
      position:absolute;
      left:10px; right:10px; bottom:10px;
      display:none;
      justify-content:space-between;
      gap:10px;
      pointer-events:none;
      opacity:.95;
    }
    .hintBox{
      flex:1;
      background:rgba(0,0,0,.32);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:10px 12px;
      font-weight:1000;
      text-align:center;
      backdrop-filter: blur(6px);
    }
    .hintBox span{display:block; font-weight:750; opacity:.9; font-size:12px; margin-top:4px;}

    @media (max-width: 520px){
      .title{font-size:24px}
      .go{font-size:17px}
      .touchHint{display:flex;}
      .help{max-width: unset;}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="start" class="start">
      <div class="row">
        <div class="logo">
          <div class="badge">H</div>
          <div>
            <h1 class="title">WELCOME</h1>
            <p class="sub">Super Hiko vs. Friends</p>
          </div>
        </div>
        <div class="help">
          <b>Телефон:</b> тап (центр) — прыжок.<br>
          Удерживай <b>слева</b> — тормоз, <b>справа</b> — ускорение.<br>
          <b>Цель:</b> добраться до <b>дома Алёны</b> и поймать флаг ❤
        </div>
      </div>

      <div id="enemyList" class="list"></div>

      <button id="go" class="go">ПОЕХАЛИ К ДОМУ АЛЁНЫ</button>
      <p class="note">Прыжок сверху по врагу: <b>BOOM</b> и +3 очка. Удар сбоку: Hiko уменьшается (3 жизни).</p>
    </div>

    <div id="hud" class="hud hidden">
      <div><b>Super Hiko</b> <span style="opacity:.85">— тап: прыжок • слева: тормоз • справа: ускорение</span></div>
      <div style="display:flex; gap:8px; align-items:center;">
        <div id="info"></div>
        <button id="reset">Рестарт</button>
      </div>
    </div>

    <div class="stage" id="stage">
      <canvas id="game" width="980" height="540"></canvas>
      <div class="touchHint" aria-hidden="true">
        <div class="hintBox">ЛЕВО<span>удерживай: ТОРМОЗ</span></div>
        <div class="hintBox">ТАП<span>прыжок</span></div>
        <div class="hintBox">ПРАВО<span>удерживай: УСКОР</span></div>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ---------- Canvas ----------
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;

  // ---------- Game content ----------
  const friends = [
    {name:"Zloy Stas", kind:"blond_mustache_man", lane:"air",   speed:320, size:"m",  spawnPoint:"topRight", motion:"dash"},
    {name:"Arkadağ", kind:"hairy_man",           lane:"ground",speed:260, size:"m",  spawnPoint:"right",    motion:"steady"},
    {name:"Timur Niva", kind:"car",              lane:"ground",speed:360, size:"xl", spawnPoint:"right",    motion:"bump"},
    {name:"Mona", kind:"slanted_eyes_girl",      lane:"mid",   speed:300, size:"l",  spawnPoint:"midRight", motion:"wobble"},
    {name:"Emil Abi", kind:"bald_mustache_man",  lane:"ground",speed:290, size:"l",  spawnPoint:"right",    motion:"steady"},
    {name:"Uno", kind:"uno_card",                lane:"mid",   speed:330, size:"l",  spawnPoint:"topRight", motion:"spin"},
    {name:"Asya", kind:"blonde_girl",            lane:"ground",speed:270, size:"m",  spawnPoint:"right",    motion:"steady"},
    {name:"Aynura", kind:"tall_black_girl",      lane:"air",   speed:310, size:"xl", spawnPoint:"topRight", motion:"dive"},
    {name:"Zamina", kind:"girl_piano",           lane:"ground",speed:250, size:"xl", spawnPoint:"right",    motion:"heavy"},
    {name:"Elnur", kind:"man_laptop",            lane:"air",   speed:305, size:"xl", spawnPoint:"topRight", motion:"drift"},
    {name:"Angelina Minsk", kind:"flower",       lane:"air",   speed:240, size:"m",  spawnPoint:"topRight", motion:"float"},
    {name:"Malika", kind:"angel",                lane:"air",   speed:235, size:"l",  spawnPoint:"topRight", motion:"float"},
    {name:"Aşkiyom", kind:"beer",                lane:"mid",   speed:285, size:"l",  spawnPoint:"midRight", motion:"zigzag"},
  ];

  // ---------- Pretty enemy cards ----------
  const palette = [
    ["#57d38e","#2b7bff"], ["#ff8a4a","#ff4aa2"], ["#ffd166","#06d6a0"],
    ["#a78bfa","#22d3ee"], ["#fb7185","#60a5fa"], ["#f59e0b","#10b981"],
    ["#34d399","#f472b6"], ["#60a5fa","#f59e0b"], ["#22c55e","#a78bfa"],
    ["#f472b6","#38bdf8"], ["#f97316","#84cc16"], ["#e879f9","#22c55e"],
    ["#38bdf8","#fda4af"],
  ];
  const enemyListEl = document.getElementById("enemyList");
  friends.forEach((e, i) => {
    const [c1,c2] = palette[i % palette.length];
    const d = document.createElement("div");
    d.className = "card";
    d.style.background = `linear-gradient(135deg, ${c1}33, ${c2}22)`;
    d.style.borderColor = `${c1}66`;
    d.innerHTML = `${e.name}<small>${e.lane==="ground"?"земля":e.lane==="mid"?"середина":"воздух"} • скорость ${Math.round(e.speed)}</small>`;
    enemyListEl.appendChild(d);
  });

  // ---------- UI ----------
  const startEl = document.getElementById("start");
  const hudEl = document.getElementById("hud");
  const infoEl = document.getElementById("info");
  const goBtn = document.getElementById("go");
  const resetBtn = document.getElementById("reset");
  const stageEl = document.getElementById("stage");

  // ---------- World (tiles) ----------
  const TILE = 32;
  const MAP_W = 210, MAP_H = 18;
  const worldPxW = MAP_W * TILE, worldPxH = MAP_H * TILE;

  const map = Array.from({length: MAP_H}, () => Array(MAP_W).fill(0));
  for (let x=0;x<MAP_W;x++){ map[MAP_H-1][x]=1; map[MAP_H-2][x]=1; }

  function putRect(tx,ty,tw,th,v=1){
    for(let y=ty;y<ty+th;y++) for(let x=tx;x<tx+tw;x++){
      if(y>=0&&y<MAP_H&&x>=0&&x<MAP_W) map[y][x]=v;
    }
  }

  // Platforms with names
  putRect(14, MAP_H-4, 10, 2, 1);            // Bornova ovası
  putRect(34, MAP_H-2-5, 10, 5, 1);          // Bayraklı üst geçit
  putRect(58, MAP_H-2-3, 12, 3, 1);          // Karşıyaka otoban girişi
  putRect(84, MAP_H-2-4, 12, 4, 1);          // Alaybey girişi
  putRect(104, MAP_H-2-2, 14, 2, 1);         // Karşıyaka

  // Final zone + castle
  const LAST_RISE_TX = 132;
  putRect(LAST_RISE_TX, MAP_H-2-3, 10, 3, 1);

  const SAFE_WALK_START_TX = LAST_RISE_TX + 10;
  putRect(SAFE_WALK_START_TX, MAP_H-2-2, 3, 2, 1);

  const CASTLE_TX = SAFE_WALK_START_TX + 3;
  putRect(CASTLE_TX, MAP_H-6, 20, 1, 1);

  const FLAG_TX = CASTLE_TX + 15;
  const POLE_TX = CASTLE_TX + 17;
  putRect(POLE_TX, MAP_H-10, 1, 8, 1);

  const STOP_OBSTACLES_X = (LAST_RISE_TX * TILE) - 40;

  const tileAt = (tx,ty)=> (tx<0||ty<0||tx>=MAP_W||ty>=MAP_H)?0:map[ty][tx];

  // ---------- Player ----------
  const stages = [
    {name:"Super Hiko", w: 38, h: 54, jump: 1080},
    {name:"Midi Hiko",  w: 30, h: 42, jump: 1040},
    {name:"Mini Hiko",  w: 26, h: 34, jump: 1010},
  ];
  const player = { x:70, y:0, vx:0, vy:0, onGround:false, stage:0, lives:3, iFrames:0 };

  const GRAV = 1850;
  const FRICTION = 0.82;
  const AIR_DRAG = 0.97;

  const cam = { x:0, y:0 };

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const aabb=(ax,ay,aw,ah,bx,by,bw,bh)=> ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;

  const pW = ()=> stages[player.stage].w;
  const pH = ()=> stages[player.stage].h;
  const pJump = ()=> stages[player.stage].jump;

  function getSolidTilesOverlapping(x,y,w,h){
    const left=Math.floor(x/TILE), right=Math.floor((x+w)/TILE);
    const top=Math.floor(y/TILE), bottom=Math.floor((y+h)/TILE);
    const tiles=[];
    for(let ty=top; ty<=bottom; ty++) for(let tx=left; tx<=right; tx++){
      if (tileAt(tx,ty)===1) tiles.push({tx,ty});
    }
    return tiles;
  }

  function collideAndSlide(dt){
    const w=pW(), h=pH();
    player.onGround=false;

    // X
    player.x += player.vx*dt;
    for(const t of getSolidTilesOverlapping(player.x,player.y,w,h)){
      const rx=t.tx*TILE, ry=t.ty*TILE;
      if(aabb(player.x,player.y,w,h, rx,ry,TILE,TILE)){
        if(player.vx>0) player.x = rx-w;
        else if(player.vx<0) player.x = rx+TILE;
        player.vx=0;
      }
    }

    // Y
    player.y += player.vy*dt;
    for(const t of getSolidTilesOverlapping(player.x,player.y,w,h)){
      const rx=t.tx*TILE, ry=t.ty*TILE;
      if(aabb(player.x,player.y,w,h, rx,ry,TILE,TILE)){
        if(player.vy>0){
          player.y = ry-h;
          player.vy=0;
          player.onGround=true;
        } else if(player.vy<0){
          player.y = ry+TILE;
          player.vy=0;
        }
      }
    }

    player.x = clamp(player.x, 0, worldPxW - w);
    if (player.y > worldPxH) reset();
  }

  // ---------- Controls (mobile-first) ----------
  let started=false, gameOver=false, cutscene=false;
  let score=0;

  let touchHold = "none"; // brake | boost | none
  let tapJumpQueued = false;
  const keys = new Set();

  addEventListener("keydown",(e)=>{
    if (["ArrowLeft","ArrowRight","ArrowUp","Space","KeyR"].includes(e.code)) e.preventDefault();
    keys.add(e.code);
    if (e.code==="KeyR") reset();
  });
  addEventListener("keyup",(e)=>keys.delete(e.code));
  resetBtn.addEventListener("click", reset);

  stageEl.addEventListener("pointerdown", (e)=>{
    if (!started) return;
    stageEl.setPointerCapture?.(e.pointerId);
    const rect = stageEl.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const zone = x / rect.width;
    if (zone < 0.33) touchHold = "brake";
    else if (zone > 0.66) touchHold = "boost";
    else { tapJumpQueued = true; touchHold = "none"; }
  }, {passive:false});

  stageEl.addEventListener("pointerup", ()=>{ touchHold="none"; }, {passive:true});
  stageEl.addEventListener("pointercancel", ()=>{ touchHold="none"; }, {passive:true});
  stageEl.addEventListener("pointermove", (e)=>{
    if (!started) return;
    if (touchHold === "none") return;
    const rect = stageEl.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const zone = x / rect.width;
    touchHold = (zone < 0.5) ? "brake" : "boost";
  }, {passive:true});

  addEventListener("touchmove", (e)=>{ if (started) e.preventDefault(); }, {passive:false});

  function applyAutoRun(dt){
    const base = 330;
    const boost = 580;
    const brake = 160;
    let target = base;

    if (keys.has("ArrowRight")) target = boost;
    if (keys.has("ArrowLeft")) target = brake;
    if (touchHold === "boost") target = boost;
    if (touchHold === "brake") target = brake;

    const k = 11;
    player.vx += (target - player.vx) * (1 - Math.exp(-k*dt));
  }

  // ---------- Obstacles (2–3 grouped, faster) ----------
  const obstacles=[];
  let timeSinceStart=0;
  let spawnIndex=0;
  let groupTimer=0;
  const lastSpawnByName = new Map();
  const activeNames = new Set();
  const spawnQueue=[]; // {tLeft, friend}

  function sizeFor(friend){
    if (friend.kind==="car") return {w:92,h:56};
    if (friend.kind==="tall_black_girl") return {w:62,h:96};
    if (friend.kind==="girl_piano") return {w:92,h:64};
    if (friend.kind==="man_laptop") return {w:84,h:64};
    if (friend.kind==="uno_card") return {w:64,h:86};
    if (friend.kind==="beer") return {w:64,h:92};
    if (friend.size==="xl") return {w:86,h:80};
    if (friend.size==="l")  return {w:76,h:76};
    return {w:70,h:72};
  }

  function laneY(friend, h){
    const groundY = (MAP_H-2)*TILE;
    if (friend.lane==="ground") return groundY - h;
    if (friend.lane==="mid") return groundY - h - (90 + Math.random()*45);
    return groundY - h - (165 + Math.random()*90);
  }

  function spawnPointXY(spawnPoint){
    const x = cam.x + W + 160 + Math.random()*80;
    if (spawnPoint==="topRight") return {x, y: 40 + Math.random()*70};
    if (spawnPoint==="midRight") return {x, y: 150 + Math.random()*110};
    return {x, y: 260 + Math.random()*130};
  }

  function canSpawn(friend){
    if (activeNames.has(friend.name)) return false;
    const last = lastSpawnByName.get(friend.name) ?? -9999;
    return (timeSinceStart - last) >= 10;
  }

  function pickNextSpawnable(){
    let tries = 0;
    while (tries < friends.length){
      const f = friends[spawnIndex % friends.length];
      spawnIndex++; tries++;
      if (canSpawn(f)) return f;
    }
    return null;
  }

  function addObstacle(friend){
    const sz = sizeFor(friend);
    const sp = spawnPointXY(friend.spawnPoint);
    const baseY = laneY(friend, sz.h);

    const o = {
      name: friend.name,
      kind: friend.kind,
      motion: friend.motion,
      x: sp.x,
      baseY,
      y: Math.min(baseY, sp.y + 140),
      w: sz.w, h: sz.h,
      vx: -friend.speed,
      vy: 0,
      t: 0,
      zigAmp: 52 + Math.random()*22,
      zigFreq: 2.6 + Math.random()*1.2,
      spin: 0,
      landed:false
    };

    if (o.motion==="dive"){
      o.y = sp.y;
      o.vy = 0;
      o.landed = false;
    }
    if (o.motion==="float"){
      o.y = baseY - (85 + Math.random()*85);
    }

    obstacles.push(o);
    activeNames.add(o.name);
    lastSpawnByName.set(o.name, timeSinceStart);
  }

  function removeObstacle(o){
    const i = obstacles.indexOf(o);
    if (i>=0) obstacles.splice(i,1);
    activeNames.delete(o.name);
  }

  function scheduleGroup(){
    const count = (Math.random() < 0.55) ? 2 : 3;
    for (let i=0;i<count;i++){
      const f = pickNextSpawnable();
      if (!f) break;
      spawnQueue.push({ tLeft: i * (0.18 + Math.random()*0.16), friend: f });
    }
  }

  function updateSpawns(dt){
    if (player.x > STOP_OBSTACLES_X) return;

    groupTimer += dt;
    if (groupTimer >= 2.0){ // faster groups
      groupTimer = 0;
      scheduleGroup();
    }

    for (let i=spawnQueue.length-1; i>=0; i--){
      spawnQueue[i].tLeft -= dt;
      if (spawnQueue[i].tLeft <= 0){
        addObstacle(spawnQueue[i].friend);
        spawnQueue.splice(i,1);
      }
    }
  }

  function updateObstacles(dt){
    if (player.x > STOP_OBSTACLES_X) return;

    for (const o of obstacles){
      o.t += dt;
      o.x += o.vx * dt;

      if (o.motion==="zigzag"){
        o.y = o.baseY + Math.sin(o.t * o.zigFreq) * o.zigAmp;
      } else if (o.motion==="float"){
        o.y = o.baseY + Math.sin(o.t*3.6) * 26;
        const pulse = 0.78 + 0.22*Math.sin(o.t*1.2);
        o.x += (o.vx * (pulse-1)) * dt;
      } else if (o.motion==="dive"){
        o.vy += 1450 * dt;
        o.y += o.vy * dt;
        if (!o.landed && o.y >= o.baseY){
          o.y = o.baseY;
          o.vy = 0;
          o.landed = true;
        }
        if (o.landed) o.y = o.baseY + Math.sin(o.t*2.6)*12;
      } else if (o.motion==="drift"){
        o.y = o.baseY + Math.sin(o.t*2.0) * 20;
        o.x += Math.sin(o.t*1.6) * 16 * dt;
      } else if (o.motion==="wobble"){
        o.y = o.baseY + Math.sin(o.t*2.9) * 18;
      } else if (o.motion==="spin"){
        o.spin += dt*7.2;
        o.y = o.baseY + Math.sin(o.t*2.4) * 16;
      } else if (o.motion==="bump"){
        o.y = o.baseY + Math.abs(Math.sin(o.t*3.2)) * -10;
      } else if (o.motion==="heavy"){
        const stop = (Math.sin(o.t*1.1) > 0.86) ? 0.15 : 1.0;
        o.x += o.vx * dt * (stop-1);
        o.y = o.baseY;
      } else if (o.motion==="dash"){
        const dash = 0.82 + 0.42*Math.max(0, Math.sin(o.t*2.1));
        o.x += o.vx * dt * (dash-1);
        o.y = o.baseY + Math.sin(o.t*3.0) * 12;
      } else {
        o.y = o.baseY;
      }
    }

    for (let i=obstacles.length-1; i>=0; i--){
      const o = obstacles[i];
      if (o.x < cam.x - 420) removeObstacle(o);
    }
  }

  // ---------- FX (BOOM) ----------
  const fxList=[];
  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }
  function spawnBoom(x,y){
    const f={x,y,t:0,life:0.6,sparks:[]};
    for(let i=0;i<30;i++){
      f.sparks.push({x:0,y:0,vx:(Math.random()*2-1)*(190+Math.random()*170),vy:-(170+Math.random()*300),r:2.8+Math.random()*3.8});
    }
    fxList.push(f);
  }
  function updateFX(dt){
    for(const f of fxList){
      f.t += dt;
      for(const p of f.sparks){
        p.vy += 980*dt;
        p.x += p.vx*dt;
        p.y += p.vy*dt;
        p.vx *= Math.pow(0.96, dt*60);
      }
    }
    for(let i=fxList.length-1;i>=0;i--) if (fxList[i].t>fxList[i].life) fxList.splice(i,1);
  }

  // ---------- Combat (shrink) ----------
  function takeHit(){
    if (player.iFrames>0) return;
    player.iFrames = 1.1;
    player.lives = Math.max(0, player.lives-1);

    if (player.lives===2){
      const oldH=pH(); player.stage=1; player.y += (oldH - pH());
    } else if (player.lives===1){
      const oldH=pH(); player.stage=2; player.y += (oldH - pH());
    } else {
      reset();
    }
    player.vx = -260;
  }

  function handleInteractions(){
    const pw=pW(), ph=pH();
    for(const o of obstacles){
      if (!aabb(player.x,player.y,pw,ph, o.x,o.y,o.w,o.h)) continue;

      const playerBottom = player.y + ph;
      const overlapTop = playerBottom - o.y;
      const wasFalling = player.vy > 140;
      const isTopHit = wasFalling && overlapTop >= 0 && overlapTop <= 22;

      if (isTopHit){
        spawnBoom(o.x + o.w/2, o.y);
        score += 3;
        removeObstacle(o);
        player.vy = -610;
      } else {
        takeHit();
      }
      break;
    }
  }

  // ---------- Castle / Flag ----------
  const castle = { x:(CASTLE_TX+8)*TILE, y:(MAP_H-2)*TILE, w:320, h:290 };
  const pole = { x:(POLE_TX)*TILE + TILE/2, topY:(MAP_H-10)*TILE, bottomY:(MAP_H-2)*TILE };

  function reachedFlag(){
    const fx = pole.x - 10;
    return player.x + pW() > fx && player.x < fx + 22 && player.onGround && player.x > (FLAG_TX*TILE - 40);
  }

  // ---------- Drawing ----------
  function drawBackground(){
    // Ege körfez sahil
    ctx.save();
    ctx.globalAlpha=0.9;
    ctx.fillStyle="rgba(0,40,90,.35)";
    ctx.fillRect(0, 92, W, 44);
    ctx.fillStyle="rgba(255,255,255,.92)";
    ctx.font="1000 22px system-ui";
    ctx.fillText("Ege körfez sahil", 18, 122);
    ctx.restore();

    const zoneX = 100*TILE;
    if (cam.x > zoneX - 400 && cam.x < zoneX + 1200){
      ctx.save();
      ctx.globalAlpha=0.85;
      ctx.fillStyle="rgba(0,0,0,.25)";
      ctx.fillRect(W-380, 146, 360, 40);
      ctx.fillStyle="#fff";
      ctx.font="1000 18px system-ui";
      ctx.fillText("Karşıyaka sahil", W-356, 172);
      ctx.restore();
    }
  }

  function drawTiles(){
    const startTx=Math.floor(cam.x/TILE);
    const endTx=Math.ceil((cam.x+W)/TILE);
    for(let ty=0; ty<MAP_H; ty++){
      for(let tx=startTx; tx<=endTx; tx++){
        if (tileAt(tx,ty)!==1) continue;
        const x=tx*TILE - cam.x;
        const y=ty*TILE - cam.y;
        const isGround = (ty >= MAP_H-2);
        ctx.fillStyle = isGround ? "rgba(40,120,60,1)" : "rgba(165,105,60,1)";
        ctx.fillRect(x,y,TILE,TILE);
        ctx.strokeStyle="rgba(0,0,0,.18)";
        ctx.strokeRect(x+0.5,y+0.5,TILE-1,TILE-1);
      }
    }
  }

  function labelAtWorld(wx,wy,text){
    const sx=wx-cam.x, sy=wy-cam.y;
    if (sx<-400 || sx>W+400) return;
    ctx.save();
    ctx.font="1000 16px system-ui";
    const tw=ctx.measureText(text).width;
    ctx.globalAlpha=0.92;
    ctx.fillStyle="rgba(0,0,0,.35)";
    ctx.fillRect(sx-6, sy-22, tw+12, 28);
    ctx.fillStyle="#fff";
    ctx.fillText(text, sx, sy-2);
    ctx.restore();
  }

  function drawLandmarks(){
    labelAtWorld(14*TILE,  (MAP_H-4)*TILE,   "Bornova ovası");
    labelAtWorld(34*TILE,  (MAP_H-2-5)*TILE, "Bayraklı üst geçit");
    labelAtWorld(58*TILE,  (MAP_H-2-3)*TILE, "Karşıyaka otoban girişi");
    labelAtWorld(84*TILE,  (MAP_H-2-4)*TILE, "Alaybey girişi");
    labelAtWorld(104*TILE, (MAP_H-2-2)*TILE, "Karşıyaka");
  }

  function drawNameTag(cx, topY, text){
    ctx.save();
    ctx.font="1000 14px system-ui";
    const tw=ctx.measureText(text).width;
    ctx.globalAlpha=0.95;
    ctx.fillStyle="rgba(0,0,0,.50)";
    ctx.fillRect(cx - tw/2 - 9, topY - 26, tw + 18, 22);
    ctx.fillStyle="#fff";
    ctx.fillText(text, cx - tw/2, topY - 10);
    ctx.restore();
  }

  // Simple character primitives
  function drawFaceBase(x,y,w,h, skin){
    ctx.fillStyle=skin;
    ctx.beginPath();
    ctx.ellipse(x+w*0.5, y+h*0.35, w*0.28, h*0.25, 0, 0, Math.PI*2);
    ctx.fill();
  }
  function drawEyes(x,y,w,h, slanted){
    ctx.save();
    ctx.strokeStyle="rgba(20,20,20,.9)";
    ctx.lineWidth=2.3;
    const ey=y+h*0.34;
    const ex1=x+w*0.43, ex2=x+w*0.57;
    if(!slanted){
      ctx.beginPath(); ctx.moveTo(ex1-7,ey); ctx.lineTo(ex1+7,ey); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ex2-7,ey); ctx.lineTo(ex2+7,ey); ctx.stroke();
    }else{
      ctx.beginPath(); ctx.moveTo(ex1-8,ey+3); ctx.lineTo(ex1+8,ey-3); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ex2-8,ey-3); ctx.lineTo(ex2+8,ey+3); ctx.stroke();
    }
    ctx.restore();
  }
  function drawMustache(x,y,w,h){
    ctx.save();
    ctx.strokeStyle="rgba(20,20,20,.95)";
    ctx.lineWidth=3.7;
    const my=y+h*0.41;
    ctx.beginPath(); ctx.moveTo(x+w*0.46,my); ctx.lineTo(x+w*0.32,my+2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+w*0.54,my); ctx.lineTo(x+w*0.68,my+2); ctx.stroke();
    ctx.restore();
  }
  function drawBody(x,y,w,h,color){
    ctx.fillStyle=color;
    ctx.fillRect(x+w*0.28, y+h*0.46, w*0.44, h*0.44);
    ctx.fillRect(x+w*0.24, y+h*0.62, w*0.18, h*0.32);
    ctx.fillRect(x+w*0.58, y+h*0.62, w*0.18, h*0.32);
  }

  function drawBlondMustacheMan(x,y,w,h){
    ctx.fillStyle="rgba(245,215,60,1)";
    ctx.beginPath(); ctx.ellipse(x+w*0.5,y+h*0.24,w*0.33,h*0.23,0,0,Math.PI*2); ctx.fill();
    drawFaceBase(x,y,w,h,"rgba(255,225,200,1)");
    drawEyes(x,y,w,h,false); drawMustache(x,y,w,h);
    drawBody(x,y,w,h,"rgba(80,120,200,1)");
  }
  function drawHairyMan(x,y,w,h){
    ctx.fillStyle="rgba(40,25,15,1)";
    ctx.beginPath(); ctx.ellipse(x+w*0.5,y+h*0.23,w*0.35,h*0.25,0,0,Math.PI*2); ctx.fill();
    drawFaceBase(x,y,w,h,"rgba(255,220,195,1)");
    drawEyes(x,y,w,h,false);
    drawBody(x,y,w,h,"rgba(60,160,120,1)");
  }
  function drawBaldMustacheMan(x,y,w,h){
    drawFaceBase(x,y,w,h,"rgba(255,225,200,1)");
    drawEyes(x,y,w,h,false); drawMustache(x,y,w,h);
    drawBody(x,y,w,h,"rgba(140,80,170,1)");
  }
  function drawSlantedEyesGirl(x,y,w,h){
    ctx.fillStyle="rgba(25,20,15,1)";
    ctx.beginPath(); ctx.ellipse(x+w*0.5,y+h*0.24,w*0.35,h*0.25,0,0,Math.PI*2); ctx.fill();
    drawFaceBase(x,y,w,h,"rgba(255,225,205,1)");
    drawEyes(x,y,w,h,true);
    drawBody(x,y,w,h,"rgba(230,90,150,1)");
  }
  function drawBlondeGirl(x,y,w,h){
    ctx.fillStyle="rgba(250,220,80,1)";
    ctx.beginPath(); ctx.ellipse(x+w*0.5,y+h*0.24,w*0.36,h*0.25,0,0,Math.PI*2); ctx.fill();
    drawFaceBase(x,y,w,h,"rgba(255,225,200,1)");
    drawEyes(x,y,w,h,false);
    drawBody(x,y,w,h,"rgba(250,120,70,1)");
  }
  function drawTallBlackGirl(x,y,w,h){
    ctx.fillStyle="rgba(10,10,10,1)";
    ctx.beginPath(); ctx.ellipse(x+w*0.5,y+h*0.24,w*0.36,h*0.26,0,0,Math.PI*2); ctx.fill();
    drawFaceBase(x,y,w,h,"rgba(145,95,70,1)");
    drawEyes(x,y,w,h,false);
    ctx.fillStyle="rgba(40,40,80,1)";
    ctx.fillRect(x+w*0.26,y+h*0.46,w*0.48,h*0.56);
  }
  function drawCar(x,y,w,h){
    ctx.fillStyle="rgba(40,90,180,1)";
    roundRect(x, y+h*0.28, w, h*0.55, 12); ctx.fill();
    ctx.fillStyle="rgba(55,120,210,1)";
    roundRect(x+w*0.18, y, w*0.56, h*0.45, 12); ctx.fill();
    ctx.fillStyle="rgba(170,230,255,.85)";
    roundRect(x+w*0.26, y+h*0.12, w*0.40, h*0.24, 10); ctx.fill();
    ctx.fillStyle="rgba(20,20,20,1)";
    ctx.beginPath(); ctx.arc(x+w*0.25,y+h*0.90,9,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+w*0.75,y+h*0.90,9,0,Math.PI*2); ctx.fill();
  }
  function drawUnoCard(x,y,w,h, spin){
    ctx.save();
    ctx.translate(x+w/2, y+h/2);
    ctx.rotate(spin);
    ctx.translate(-w/2, -h/2);
    ctx.fillStyle="rgba(200,30,40,1)";
    roundRect(0,0,w,h,12); ctx.fill();
    ctx.fillStyle="rgba(255,255,255,.95)";
    ctx.font="1000 18px system-ui";
    ctx.fillText("UNO", 12, h*0.66);
    ctx.restore();
  }
  function drawGirlWithPiano(x,y,w,h){
    drawBlondeGirl(x,y,w*0.55,h);
    const px=x+w*0.50, py=y+h*0.56;
    ctx.fillStyle="rgba(20,20,25,1)";
    roundRect(px,py,w*0.48,h*0.34,10); ctx.fill();
    ctx.fillStyle="rgba(255,255,255,.9)";
    for(let i=0;i<6;i++) ctx.fillRect(px+7+i*9, py+h*0.22, 5, 12);
  }
  function drawManWithLaptop(x,y,w,h){
    drawHairyMan(x,y,w*0.55,h);
    const lx=x+w*0.52, ly=y+h*0.60;
    ctx.fillStyle="rgba(30,30,35,1)";
    roundRect(lx,ly,w*0.44,h*0.24,9); ctx.fill();
    ctx.fillStyle="rgba(120,200,255,.85)";
    roundRect(lx+5,ly+5,w*0.44-10,h*0.24-12,8); ctx.fill();
  }
  function drawFlower(x,y,w,h){
    const cx=x+w*0.52, cy=y+h*0.48;
    ctx.save(); ctx.translate(cx,cy);
    ctx.fillStyle="rgba(255,200,0,.95)";
    for(let i=0;i<6;i++){
      ctx.rotate(Math.PI/3);
      ctx.beginPath(); ctx.ellipse(0,-h*0.20,w*0.12,h*0.18,0,0,Math.PI*2); ctx.fill();
    }
    ctx.fillStyle="rgba(255,80,80,.95)";
    ctx.beginPath(); ctx.arc(0,0,Math.min(w,h)*0.13,0,Math.PI*2); ctx.fill();
    ctx.restore();
    ctx.fillStyle="rgba(30,130,70,.95)";
    ctx.fillRect(x+w*0.48,y+h*0.40,w*0.06,h*0.60);
  }
  function drawAngel(x,y,w,h){
    ctx.fillStyle="rgba(255,255,255,.92)";
    ctx.beginPath();
    ctx.ellipse(x+w*0.30,y+h*0.52,w*0.22,h*0.20,-0.4,0,Math.PI*2);
    ctx.ellipse(x+w*0.70,y+h*0.52,w*0.22,h*0.20,0.4,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle="rgba(255,230,120,.95)";
    ctx.lineWidth=4;
    ctx.beginPath(); ctx.ellipse(x+w*0.50,y+h*0.18,w*0.18,h*0.10,0,0,Math.PI*2); ctx.stroke();
    ctx.fillStyle="rgba(240,240,255,1)";
    roundRect(x+w*0.35,y+h*0.28,w*0.30,h*0.62,12); ctx.fill();
    ctx.fillStyle="rgba(25,20,15,1)";
    ctx.beginPath(); ctx.ellipse(x+w*0.50,y+h*0.22,w*0.20,h*0.16,0,0,Math.PI*2); ctx.fill();
    drawFaceBase(x,y,w,h,"rgba(255,225,200,1)");
    drawEyes(x,y,w,h,false);
  }
  function drawBeer(x,y,w,h){
    ctx.fillStyle="rgba(255,255,255,.85)";
    roundRect(x+w*0.22,y+h*0.18,w*0.52,h*0.72,12); ctx.fill();
    ctx.fillStyle="rgba(255,190,40,.95)";
    roundRect(x+w*0.24,y+h*0.34,w*0.48,h*0.54,10); ctx.fill();
    ctx.strokeStyle="rgba(255,255,255,.85)";
    ctx.lineWidth=7;
    ctx.beginPath();
    ctx.arc(x+w*0.76,y+h*0.52,w*0.12,-Math.PI/2,Math.PI/2);
    ctx.stroke();
  }

  function drawObstacle(o){
    const x = Math.round(o.x - cam.x);
    const y = Math.round(o.y - cam.y);

    // shadow
    ctx.fillStyle="rgba(0,0,0,.16)";
    ctx.beginPath();
    ctx.ellipse(x+o.w/2, y+o.h+12, o.w*0.45, 8, 0, 0, Math.PI*2);
    ctx.fill();

    if (o.kind==="blond_mustache_man") drawBlondMustacheMan(x,y,o.w,o.h);
    else if (o.kind==="hairy_man") drawHairyMan(x,y,o.w,o.h);
    else if (o.kind==="car") drawCar(x,y,o.w,o.h);
    else if (o.kind==="slanted_eyes_girl") drawSlantedEyesGirl(x,y,o.w,o.h);
    else if (o.kind==="bald_mustache_man") drawBaldMustacheMan(x,y,o.w,o.h);
    else if (o.kind==="uno_card") drawUnoCard(x,y,o.w,o.h,o.spin);
    else if (o.kind==="blonde_girl") drawBlondeGirl(x,y,o.w,o.h);
    else if (o.kind==="tall_black_girl") drawTallBlackGirl(x,y,o.w,o.h);
    else if (o.kind==="girl_piano") drawGirlWithPiano(x,y,o.w,o.h);
    else if (o.kind==="man_laptop") drawManWithLaptop(x,y,o.w,o.h);
    else if (o.kind==="flower") drawFlower(x,y,o.w,o.h);
    else if (o.kind==="angel") drawAngel(x,y,o.w,o.h);
    else if (o.kind==="beer"){
      // zigzag trail
      ctx.save();
      ctx.globalAlpha=0.55;
      ctx.strokeStyle="rgba(255,255,255,.9)";
      ctx.lineWidth=2;
      ctx.beginPath();
      const steps=8;
      for(let i=0;i<=steps;i++){
        const px = x + i*(o.w/steps);
        const py = y + o.h*0.45 + Math.sin(o.t*o.zigFreq + i*0.9) * 12;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.restore();
      drawBeer(x,y,o.w,o.h);
    }

    drawNameTag(x+o.w/2, y, o.name);
  }

  function drawObstacles(){ for(const o of obstacles) drawObstacle(o); }

  function drawFX(){
    for(const f of fxList){
      const a = clamp(1 - (f.t / f.life), 0, 1);
      const sx=f.x-cam.x, sy=f.y-cam.y;

      ctx.save();
      ctx.globalAlpha = 0.95*a;
      ctx.fillStyle="rgba(0,0,0,.42)";
      roundRect(sx-66, sy-76, 132, 40, 12); ctx.fill();
      ctx.fillStyle="#fff";
      ctx.font="1000 24px system-ui";
      ctx.fillText("BOOM", sx-40, sy-48);
      ctx.restore();

      for(const p of f.sparks){
        const px=sx+p.x, py=sy+p.y;
        const hot=clamp(1 - f.t/f.life, 0, 1);
        ctx.save();
        ctx.globalAlpha=0.85*a;
        ctx.fillStyle=`rgba(255,${Math.floor(150+hot*90)},${Math.floor(30+hot*50)},1)`;
        ctx.beginPath(); ctx.arc(px,py,p.r,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }
  }

  function drawPlayer(){
    const w=pW(), h=pH();
    const x=Math.round(player.x-cam.x);
    const y=Math.round(player.y-cam.y);
    const blink = player.iFrames>0 ? (Math.floor(performance.now()/80)%2===0) : true;
    if(!blink) return;

    // shadow
    ctx.fillStyle="rgba(0,0,0,.18)";
    ctx.beginPath(); ctx.ellipse(x+w/2, y+h+6, w*0.55, 8, 0, 0, Math.PI*2); ctx.fill();

    // body
    ctx.fillStyle="rgba(30,40,55,1)";
    roundRect(x+2, y+Math.max(12, h*0.28), w-4, h*0.72, 12); ctx.fill();
    ctx.fillStyle="rgba(245,245,245,1)";
    roundRect(x+3, y+Math.max(22, h*0.55), w-6, h*0.45, 12); ctx.fill();

    // face
    ctx.fillStyle="rgba(255,225,200,1)";
    ctx.beginPath(); ctx.ellipse(x+w/2, y+12, w*0.22, h*0.18, 0, 0, Math.PI*2); ctx.fill();

    // eyes
    ctx.strokeStyle="rgba(20,20,20,.95)";
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(x+w/2-3, y+14); ctx.lineTo(x+w/2-13, y+15); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+w/2+3, y+14); ctx.lineTo(x+w/2+13, y+15); ctx.stroke();

    // green cap
    ctx.fillStyle="rgba(50,170,90,1)";
    roundRect(x-2, y+2, w+4, h*0.14, 12); ctx.fill();
    ctx.fillStyle="rgba(40,140,75,1)";
    roundRect(x+2, y-7, w-4, h*0.11, 12); ctx.fill();
  }

  function drawHUD(){
    ctx.save();
    ctx.globalAlpha=0.92;
    ctx.fillStyle="rgba(0,0,0,.28)";
    roundRect(18, 18, 360, 58, 14); ctx.fill();
    ctx.fillStyle="#fff";
    ctx.font="1000 16px system-ui";
    ctx.fillText("Счёт: " + score, 34, 50);

    // hearts
    for(let i=0;i<3;i++){
      const hx=215 + i*28, hy=46;
      ctx.fillStyle = (i<player.lives) ? "rgba(255,80,90,1)" : "rgba(255,255,255,.25)";
      ctx.beginPath();
      ctx.arc(hx, hy, 7.5, 0, Math.PI*2);
      ctx.arc(hx+12, hy, 7.5, 0, Math.PI*2);
      ctx.lineTo(hx+6, hy+18);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  // BIG Alena at finish
  function drawAlenaBig(x,y){
    ctx.save();
    ctx.globalAlpha=0.25;
    ctx.fillStyle="rgba(255,220,80,1)";
    ctx.beginPath(); ctx.ellipse(x, y-120, 70, 70, 0, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;

    // hair
    ctx.fillStyle="rgba(250,225,95,1)";
    ctx.beginPath(); ctx.ellipse(x, y-118, 62, 44, 0, 0, Math.PI*2); ctx.fill();

    // face
    ctx.fillStyle="rgba(255,225,200,1)";
    ctx.beginPath(); ctx.ellipse(x, y-112, 26, 26, 0, 0, Math.PI*2); ctx.fill();

    // eyes
    ctx.strokeStyle="rgba(25,25,25,.95)";
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(x-14, y-114); ctx.lineTo(x-4, y-114); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+4, y-114); ctx.lineTo(x+14, y-114); ctx.stroke();

    // white dress
    ctx.fillStyle="rgba(255,255,255,.96)";
    roundRect(x-46, y-82, 92, 120, 26); ctx.fill();

    // yellow belt
    ctx.fillStyle="rgba(255,210,60,1)";
    roundRect(x-36, y-24, 72, 14, 10); ctx.fill();

    // sleeves
    ctx.fillStyle="rgba(255,255,255,.95)";
    roundRect(x-68, y-70, 30, 48, 18); ctx.fill();
    roundRect(x+38, y-70, 30, 48, 18); ctx.fill();

    // heart
    ctx.fillStyle="rgba(255,80,110,1)";
    ctx.beginPath();
    ctx.arc(x-10, y+22, 8, 0, Math.PI*2);
    ctx.arc(x+10, y+22, 8, 0, Math.PI*2);
    ctx.lineTo(x, y+40);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  function drawDialog(text){
    ctx.save();
    ctx.globalAlpha=0.98;
    ctx.fillStyle="rgba(0,0,0,.62)";
    roundRect(38, H-155, W-76, 108, 16); ctx.fill();
    ctx.fillStyle="#fff";
    ctx.font="1000 30px system-ui";
    ctx.fillText(text, 70, H-95);
    ctx.font="800 14px system-ui";
    ctx.fillStyle="rgba(255,255,255,.82)";
    ctx.fillText("Игра окончена — нажми R / Рестарт", 70, H-62);
    ctx.restore();
  }

  function drawCastle(){
    const sx=castle.x-cam.x;
    const sy=(MAP_H-2)*TILE - castle.h;

    ctx.fillStyle="rgba(170,150,120,1)";
    roundRect(sx,sy,castle.w,castle.h,18); ctx.fill();

    ctx.fillStyle="rgba(0,0,0,.45)";
    roundRect(sx+castle.w*0.16, sy+14, castle.w*0.68, 42, 12); ctx.fill();
    ctx.fillStyle="#fff";
    ctx.font="1000 22px system-ui";
    ctx.fillText("Дом Алёны", sx+castle.w*0.30, sy+44);

    // pole + flag
    const px=pole.x-cam.x;
    ctx.strokeStyle="rgba(40,40,40,.9)";
    ctx.lineWidth=6;
    ctx.beginPath();
    ctx.moveTo(px, pole.topY - cam.y);
    ctx.lineTo(px, pole.bottomY - cam.y);
    ctx.stroke();

    ctx.fillStyle="rgba(240,60,60,.95)";
    ctx.beginPath();
    ctx.moveTo(px, pole.topY - cam.y + 18);
    ctx.lineTo(px+52, pole.topY - cam.y + 32);
    ctx.lineTo(px, pole.topY - cam.y + 46);
    ctx.closePath();
    ctx.fill();

    if (cutscene || gameOver){
      drawAlenaBig(sx+castle.w*0.84, sy+castle.h*0.86);
      drawDialog("WELCOME KOXANIE ❤");
    }
  }

  // ---------- Game loop ----------
  function update(dt){
    if (gameOver) return;

    if (player.iFrames>0) player.iFrames = Math.max(0, player.iFrames-dt);

    // cutscene: walk to Alena
    if (cutscene){
      player.vx = 170;
      player.vy += GRAV*dt;
      collideAndSlide(dt);

      if (player.x > castle.x - 90){
        player.vx = 0;
        gameOver = true;
      }

      cam.x = clamp(player.x + pW()/2 - W*0.40, 0, worldPxW - W);
      cam.y = 0;

      updateFX(dt);
      infoEl.textContent = `ФИНАЛ • Счёт:${score} • Жизни:${player.lives}`;
      return;
    }

    timeSinceStart += dt;

    updateSpawns(dt);
    updateObstacles(dt);

    // jump input
    const jumpKey = keys.has("ArrowUp") || keys.has("Space");
    if ((jumpKey || tapJumpQueued) && player.onGround){
      player.vy = -pJump();
      player.onGround=false;
    }
    tapJumpQueued = false;

    applyAutoRun(dt);

    // physics
    player.vy += GRAV*dt;
    if (player.onGround){
      player.vx *= FRICTION;
      if (Math.abs(player.vx)<10) player.vx=0;
    } else {
      player.vx *= AIR_DRAG;
    }

    collideAndSlide(dt);

    cam.x = clamp(player.x + pW()/2 - W*0.40, 0, worldPxW - W);
    cam.y = 0;

    // UNO spin
    for(const o of obstacles) if (o.kind==="uno_card") o.spin += dt*7.2;

    handleInteractions();
    updateFX(dt);

    // finish
    if (reachedFlag()){
      cutscene = true;
      player.x = pole.x - 18;
      player.vx = 170;
      spawnQueue.length = 0;
    }

    infoEl.textContent = `Счёт:${score} • ${stages[player.stage].name} • Жизни:${player.lives} • Friends:${obstacles.length}`;
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    drawBackground();
    drawTiles();
    drawLandmarks();
    drawObstacles();
    drawFX();
    drawCastle();
    drawPlayer();
    drawHUD();
  }

  function reset(){
    if (!started) return;
    player.x=70; player.y=0; player.vx=0; player.vy=0;
    player.stage=0; player.lives=3; player.iFrames=0;
    cam.x=0; cam.y=0;

    obstacles.length=0;
    fxList.length=0;
    score=0;

    gameOver=false; cutscene=false;

    timeSinceStart=0;
    spawnIndex=0;
    groupTimer=0;
    spawnQueue.length=0;
    lastSpawnByName.clear();
    activeNames.clear();

    touchHold="none";
    tapJumpQueued=false;
  }

  let last=performance.now();
  function loop(now){
    const dt=Math.min(0.033,(now-last)/1000);
    last=now;
    if (started){ update(dt); draw(); }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ---------- Start ----------
  goBtn.addEventListener("click", ()=>{
    startEl.classList.add("hidden");
    hudEl.classList.remove("hidden");
    canvas.style.display="block";
    started=true;
    reset();
  });

})();
</script>
</body>
</html>
