<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Super Hiko vs Friends</title>
  <style>
    html,body{height:100%;margin:0;background:#070b14;overflow:hidden;font-family:system-ui,Arial;color:#eaf0ff}
    #menu{
      position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
      background:radial-gradient(1200px 700px at 50% 0%, #14245a 0%, #070b14 60%);
      padding:16px; box-sizing:border-box;
    }
    .panel{
      width:min(980px,96vw);
      border:1px solid rgba(255,255,255,.14);
      border-radius:18px;
      background:linear-gradient(180deg, rgba(24,36,72,.92), rgba(10,14,30,.92));
      box-shadow:0 16px 45px rgba(0,0,0,.55);
      padding:16px; position:relative; overflow:hidden;
    }
    .panel:before{
      content:""; position:absolute; inset:-60px;
      background:
        radial-gradient(240px 240px at 20% 15%, rgba(80,180,120,.18), transparent 62%),
        radial-gradient(300px 300px at 80% 25%, rgba(70,120,220,.20), transparent 65%),
        radial-gradient(320px 320px at 50% 110%, rgba(220,80,170,.14), transparent 65%);
      pointer-events:none;
    }
    .top{display:flex;gap:12px;flex-wrap:wrap;align-items:flex-start;justify-content:space-between;position:relative}
    .brand{display:flex;gap:10px;align-items:center}
    .badge{width:44px;height:44px;border-radius:14px;display:grid;place-items:center;font-weight:1000;
      background:linear-gradient(135deg, rgba(80,180,120,.95), rgba(70,120,220,.95));
      box-shadow:0 10px 25px rgba(0,0,0,.35);
    }
    h1{margin:0;font-size:28px;font-weight:1000}
    .sub{margin:2px 0 0;opacity:.9;font-weight:800}
    .help{
      max-width:460px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.04);
      border-radius:14px;
      padding:10px 12px;
      font-size:13px; line-height:1.35;
      color:rgba(255,255,255,.82);
    }
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(170px,1fr));gap:9px;margin:12px 0 14px;position:relative}
    .card{
      border-radius:14px;
      border:1px solid rgba(255,255,255,.16);
      padding:10px 12px;
      box-shadow:0 10px 18px rgba(0,0,0,.18);
      font-weight:1000;
      background:rgba(255,255,255,.04);
    }
    .card small{display:block;margin-top:3px;font-weight:800;opacity:.92;font-size:12px}
    .go{
      width:100%; border-radius:16px; border:1px solid rgba(255,255,255,.22);
      padding:14px 16px; cursor:pointer; font-size:18px; font-weight:1000; color:#fff;
      background:linear-gradient(135deg, rgba(80,180,120,.95), rgba(70,120,220,.95));
      box-shadow:0 14px 30px rgba(0,0,0,.35);
    }
    .note{margin:10px 0 0;font-size:12px;opacity:.75;position:relative}

    /* Game */
    #gameWrap{position:fixed;inset:0;display:none;background:#000;}
    canvas{position:absolute;inset:0;width:100vw;height:100vh;image-rendering:pixelated}

    .hud{
      position:absolute;top:10px;left:10px;right:10px;
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      z-index:5; pointer-events:none;
    }
    .hud .left, .hud .right{display:flex;gap:10px;align-items:center;pointer-events:auto}
    .btn{
      background:rgba(15,24,52,.92); color:#eaf0ff;
      border:1px solid rgba(255,255,255,.15);
      padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:1000;
    }
    .scoreBox{
      background:rgba(0,0,0,.28);
      border:1px solid rgba(255,255,255,.12);
      padding:10px 12px;border-radius:12px;font-weight:1000;
      box-shadow:0 10px 18px rgba(0,0,0,.18);
    }

    /* Overlay welcome */
    #overlay{
      position:absolute; inset:0; display:none; align-items:flex-end; justify-content:center;
      padding:18px; z-index:6; pointer-events:none;
    }
    #overlay .box{
      width:min(760px,92vw);
      background:rgba(0,0,0,.62);
      border:1px solid rgba(255,255,255,.16);
      border-radius:16px;
      padding:16px 16px 14px;
      box-shadow:0 18px 50px rgba(0,0,0,.45);
      backdrop-filter: blur(6px);
    }
    #overlay h2{margin:0;font-size:32px;font-weight:1000}
    #overlay p{margin:6px 0 0;font-size:18px;font-weight:900;opacity:.92}

    @media (max-width:520px){
      h1{font-size:24px}
      .go{font-size:17px}
    }
  </style>
</head>
<body>
  <div id="menu">
    <div class="panel">
      <div class="top">
        <div class="brand">
          <div class="badge">H</div>
          <div>
            <h1>WELCOME</h1>
            <div class="sub">Super Hiko vs. Friends</div>
          </div>
        </div>
        <div class="help">
          <b>Телефон:</b> тап по экрану — прыжок.<br>
          Удерживай слева — тормоз, справа — ускорение.<br>
          <b>Цель:</b> пройти линию флага у дома Алёны ❤
        </div>
      </div>

      <div class="grid" id="list"></div>

      <button class="go" id="startBtn">ПОЕХАЛИ К ДОМУ АЛЁНЫ</button>
      <div class="note">Сверху по врагу: <b>BOOM</b> и +3 очка. Сбоку: уменьшаемся (3 жизни).</div>
    </div>
  </div>

  <div id="gameWrap">
    <canvas id="c" width="960" height="540"></canvas>

    <div class="hud">
      <div class="left">
        <button class="btn" id="back">⬅</button>
        <button class="btn" id="restart">⟲</button>
      </div>
      <div class="right">
        <div class="scoreBox" id="hudText">Счёт: 0 • ❤❤❤</div>
      </div>
    </div>

    <div id="overlay">
      <div class="box">
        <h2>WELCOME KOXANIE ❤</h2>
        <p id="finalScore">Счёт: 0</p>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ---------- Data ----------
  const friends = [
    {name:"Zloy Stas", kind:"blond_mustache_man", lane:"air",   speed:360, motion:"dash"},
    {name:"Arkadağ", kind:"hairy_man",           lane:"ground",speed:300, motion:"steady"},
    {name:"Timur Niva", kind:"car",              lane:"ground",speed:420, motion:"bump"},
    {name:"Mona", kind:"slanted_girl",           lane:"mid",   speed:350, motion:"wobble"},
    {name:"Emil Abi", kind:"bald_mustache_man",  lane:"ground",speed:340, motion:"steady"},
    {name:"Uno", kind:"uno_card",                lane:"mid",   speed:380, motion:"spin"},
    {name:"Asya", kind:"blonde_girl",            lane:"ground",speed:310, motion:"steady"},
    {name:"Aynura", kind:"tall_black_girl",      lane:"air",   speed:360, motion:"dive"},
    {name:"Zamina", kind:"girl_piano",           lane:"ground",speed:290, motion:"heavy"},
    {name:"Elnur", kind:"man_laptop",            lane:"air",   speed:350, motion:"drift"},
    {name:"Angelina Minsk", kind:"flower",       lane:"air",   speed:270, motion:"float"},
    {name:"Malika", kind:"angel",                lane:"air",   speed:260, motion:"float"},
    {name:"Aşkiyom", kind:"beer",                lane:"mid",   speed:320, motion:"zigzag"},
  ];

  // Fill menu list
  const list = document.getElementById("list");
  const palette = [
    ["#57d38e","#2b7bff"], ["#ff8a4a","#ff4aa2"], ["#ffd166","#06d6a0"],
    ["#a78bfa","#22d3ee"], ["#fb7185","#60a5fa"], ["#f59e0b","#10b981"],
    ["#34d399","#f472b6"], ["#60a5fa","#f59e0b"], ["#22c55e","#a78bfa"],
    ["#f472b6","#38bdf8"], ["#f97316","#84cc16"], ["#e879f9","#22c55e"],
    ["#38bdf8","#fda4af"],
  ];
  friends.forEach((e,i)=>{
    const [a,b]=palette[i%palette.length];
    const d=document.createElement("div");
    d.className="card";
    d.style.background=`linear-gradient(135deg, ${a}30, ${b}20)`;
    d.style.borderColor=`${a}66`;
    d.innerHTML = `${e.name}<small>${e.lane==="ground"?"земля":e.lane==="mid"?"середина":"воздух"} • каждые 3 сек</small>`;
    list.appendChild(d);
  });

  // ---------- DOM ----------
  const menu = document.getElementById("menu");
  const gameWrap = document.getElementById("gameWrap");
  const startBtn = document.getElementById("startBtn");
  const backBtn = document.getElementById("back");
  const restartBtn = document.getElementById("restart");
  const hudText = document.getElementById("hudText");
  const overlay = document.getElementById("overlay");
  const finalScore = document.getElementById("finalScore");

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // ---------- Fullscreen attempt ----------
  async function tryFullscreen(){
    try{
      const el = document.documentElement;
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    }catch(_){}
  }

  // ---------- Game constants ----------
  const BASE_W = 960, BASE_H = 540;

  const TILE = 32;
  const MAP_W = 210, MAP_H = 18;
  const WORLD_W = MAP_W*TILE, WORLD_H = MAP_H*TILE;

  const GRAV = 1850;

  // Simple tile map
  const map = Array.from({length:MAP_H},()=>Array(MAP_W).fill(0));
  for(let x=0;x<MAP_W;x++){ map[MAP_H-1][x]=1; map[MAP_H-2][x]=1; }
  function putRect(tx,ty,tw,th){
    for(let y=ty;y<ty+th;y++)for(let x=tx;x<tx+tw;x++){
      if(y>=0&&y<MAP_H&&x>=0&&x<MAP_W) map[y][x]=1;
    }
  }
  const tileAt=(tx,ty)=> (tx<0||ty<0||tx>=MAP_W||ty>=MAP_H)?0:map[ty][tx];

  // Platforms and landmarks
  putRect(14, MAP_H-4, 10, 2);        // Bornova ovası
  putRect(34, MAP_H-2-5, 10, 5);      // Bayraklı üst geçit
  putRect(58, MAP_H-2-3, 12, 3);      // Karşıyaka otoban girişi
  putRect(84, MAP_H-2-4, 12, 4);      // Alaybey girişi
  putRect(104, MAP_H-2-2, 14, 2);     // Karşıyaka

  // Final rise + safe walk + castle
  const LAST_RISE_TX = 132;
  putRect(LAST_RISE_TX, MAP_H-2-3, 10, 3);

  const SAFE_WALK_TX = LAST_RISE_TX + 10;
  putRect(SAFE_WALK_TX, MAP_H-2-2, 6, 2);

  const CASTLE_TX = SAFE_WALK_TX + 6;
  putRect(CASTLE_TX, MAP_H-6, 20, 1);

  const FLAG_LINE_X = (SAFE_WALK_TX*TILE) - 8;
  const STOP_OBS_X = (LAST_RISE_TX*TILE) - 40;

  const castle = { x:(CASTLE_TX+8)*TILE, y:(MAP_H-2)*TILE, w:320, h:290 };
  const pole = { x:(CASTLE_TX+17)*TILE + TILE/2, topY:(MAP_H-10)*TILE, bottomY:(MAP_H-2)*TILE };

  // ---------- Player (2x bigger) ----------
  const stages = [
    {name:"Super Hiko", w:76, h:108, jump:1180},
    {name:"Midi Hiko",  w:60, h:84,  jump:1120},
    {name:"Mini Hiko",  w:52, h:68,  jump:1080},
  ];
  const player = { x:70, y:0, vx:0, vy:0, onGround:false, stage:0, lives:3, iFrames:0 };

  const pW=()=>stages[player.stage].w;
  const pH=()=>stages[player.stage].h;
  const pJump=()=>stages[player.stage].jump;

  // ---------- Camera ----------
  const cam = { x:0, y:0 };

  // ---------- Utils ----------
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const aabb=(ax,ay,aw,ah,bx,by,bw,bh)=> ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;

  function solidTiles(x,y,w,h){
    const left=Math.floor(x/TILE), right=Math.floor((x+w)/TILE);
    const top=Math.floor(y/TILE), bottom=Math.floor((y+h)/TILE);
    const out=[];
    for(let ty=top;ty<=bottom;ty++)for(let tx=left;tx<=right;tx++){
      if(tileAt(tx,ty)===1) out.push({tx,ty});
    }
    return out;
  }

  function collide(dt){
    const w=pW(), h=pH();
    player.onGround=false;

    player.x += player.vx*dt;
    for(const t of solidTiles(player.x,player.y,w,h)){
      const rx=t.tx*TILE, ry=t.ty*TILE;
      if(aabb(player.x,player.y,w,h, rx,ry,TILE,TILE)){
        if(player.vx>0) player.x = rx-w;
        else if(player.vx<0) player.x = rx+TILE;
        player.vx=0;
      }
    }

    player.y += player.vy*dt;
    for(const t of solidTiles(player.x,player.y,w,h)){
      const rx=t.tx*TILE, ry=t.ty*TILE;
      if(aabb(player.x,player.y,w,h, rx,ry,TILE,TILE)){
        if(player.vy>0){
          player.y = ry-h;
          player.vy=0;
          player.onGround=true;
        }else if(player.vy<0){
          player.y = ry+TILE;
          player.vy=0;
        }
      }
    }

    player.x = clamp(player.x, 0, WORLD_W - w);
    if(player.y > WORLD_H + 200) resetGame();
  }

  // ---------- Controls (no on-screen hints) ----------
  let hold = "none";       // brake | boost | none
  let jumpQueued=false;

  function onPointerDown(e){
    if(!running) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const zone = x / rect.width;
    if(zone < 0.33) hold="brake";
    else if(zone > 0.66) hold="boost";
    else { jumpQueued=true; hold="none"; }
  }
  function onPointerUp(){ hold="none"; }

  canvas.addEventListener("pointerdown", onPointerDown, {passive:true});
  canvas.addEventListener("pointerup", onPointerUp, {passive:true});
  canvas.addEventListener("pointercancel", onPointerUp, {passive:true});

  // prevent scroll while playing
  window.addEventListener("touchmove", (e)=>{ if(running) e.preventDefault(); }, {passive:false});

  function autoRun(dt){
    const base=340, boost=620, brake=150;
    let target=base;
    if(hold==="boost") target=boost;
    if(hold==="brake") target=brake;
    const k=10;
    player.vx += (target - player.vx) * (1 - Math.exp(-k*dt));
  }

  // ---------- Obstacles ----------
  const obstacles=[];
  const activeNames=new Set();
  const lastSpawn=new Map();
  let spawnIndex=0;
  let spawnTimer=0;

  function obsSize(kind){
    if(kind==="car") return {w:160,h:100};
    if(kind==="tall_black_girl") return {w:110,h:170};
    if(kind==="uno_card") return {w:120,h:160};
    if(kind==="beer") return {w:120,h:170};
    if(kind==="girl_piano") return {w:170,h:120};
    if(kind==="man_laptop") return {w:160,h:120};
    if(kind==="angel") return {w:150,h:150};
    return {w:140,h:140};
  }

  function laneY(lane,h){
    const groundY=(MAP_H-2)*TILE;
    if(lane==="ground") return groundY - h;
    if(lane==="mid") return groundY - h - (120 + Math.random()*60);
    return groundY - h - (210 + Math.random()*110);
  }

  function canSpawn(name, time){
    if(activeNames.has(name)) return false;
    const last=lastSpawn.get(name) ?? -9999;
    return (time-last) >= 2; // allow repeats later, but not immediate duplicates
  }

  function spawnOne(time){
    // pick next friend that can spawn
    for(let tries=0;tries<friends.length;tries++){
      const f = friends[spawnIndex % friends.length];
      spawnIndex++;
      if(!canSpawn(f.name, time)) continue;

      const sz = obsSize(f.kind);
      const baseY = laneY(f.lane, sz.h);
      const startX = cam.x + BASE_W + 220 + Math.random()*140;

      const o = {
        name:f.name, kind:f.kind, motion:f.motion,
        x:startX, baseY, y:baseY,
        w:sz.w, h:sz.h,
        vx:-f.speed, vy:0,
        t:0, spin:0,
        zigAmp:70+Math.random()*35,
        zigFreq:2.2+Math.random()*1.2,
        landed:false
      };

      // motion init
      if(o.motion==="dive"){ o.y = 40 + Math.random()*120; o.vy=0; o.landed=false; }
      if(o.motion==="float"){ o.y = baseY - (120 + Math.random()*140); }

      obstacles.push(o);
      activeNames.add(o.name);
      lastSpawn.set(o.name, time);
      return;
    }
  }

  function spawnWave(time){
    // always 1 obstacle every 3 seconds + sometimes add 1-2 extra for group
    spawnOne(time);
    if(Math.random()<0.45) spawnOne(time+0.01);
    if(Math.random()<0.22) spawnOne(time+0.02);
  }

  function updateObstacles(dt){
    for(const o of obstacles){
      o.t += dt;
      o.x += o.vx*dt;

      if(o.motion==="zigzag"){
        o.y = o.baseY + Math.sin(o.t*o.zigFreq)*o.zigAmp;
      }else if(o.motion==="float"){
        o.y = o.baseY + Math.sin(o.t*3.0)*34;
        const pulse = 0.80 + 0.20*Math.sin(o.t*1.2);
        o.x += (o.vx*(pulse-1))*dt;
      }else if(o.motion==="dive"){
        o.vy += 1450*dt;
        o.y += o.vy*dt;
        if(!o.landed && o.y >= o.baseY){
          o.y = o.baseY; o.vy=0; o.landed=true;
        }
        if(o.landed) o.y = o.baseY + Math.sin(o.t*2.3)*14;
      }else if(o.motion==="drift"){
        o.y = o.baseY + Math.sin(o.t*2.0)*26;
        o.x += Math.sin(o.t*1.5)*22*dt;
      }else if(o.motion==="wobble"){
        o.y = o.baseY + Math.sin(o.t*2.8)*22;
      }else if(o.motion==="spin"){
        o.spin += dt*6.2;
        o.y = o.baseY + Math.sin(o.t*2.3)*20;
      }else if(o.motion==="bump"){
        o.y = o.baseY + Math.abs(Math.sin(o.t*3.2)) * -14;
      }else if(o.motion==="heavy"){
        const stop = (Math.sin(o.t*1.1)>0.86) ? 0.15 : 1.0;
        o.x += o.vx*dt*(stop-1);
        o.y = o.baseY;
      }else if(o.motion==="dash"){
        const dash = 0.80 + 0.45*Math.max(0, Math.sin(o.t*2.1));
        o.x += o.vx*dt*(dash-1);
        o.y = o.baseY + Math.sin(o.t*2.9)*16;
      }
    }

    // cleanup
    for(let i=obstacles.length-1;i>=0;i--){
      const o=obstacles[i];
      if(o.x < cam.x - 600){
        obstacles.splice(i,1);
        activeNames.delete(o.name);
      }
    }
  }

  // ---------- FX BOOM ----------
  const fx=[];
  function boom(x,y){
    const f={x,y,t:0,life:0.6,sparks:[]};
    for(let i=0;i<26;i++){
      f.sparks.push({x:0,y:0,vx:(Math.random()*2-1)*(220+Math.random()*240),vy:-(220+Math.random()*340),r:3+Math.random()*4});
    }
    fx.push(f);
  }
  function updateFX(dt){
    for(const f of fx){
      f.t+=dt;
      for(const p of f.sparks){
        p.vy += 980*dt;
        p.x += p.vx*dt;
        p.y += p.vy*dt;
        p.vx *= Math.pow(0.96, dt*60);
      }
    }
    for(let i=fx.length-1;i>=0;i--) if(fx[i].t>fx[i].life) fx.splice(i,1);
  }

  // ---------- Game state ----------
  let running=false;
  let score=0;
  let flagTriggered=false;
  let cutscene=false;
  let gameOver=false;
  let time=0;

  function hearts(){
    return "❤".repeat(player.lives) + "♡".repeat(3-player.lives);
  }

  function takeHit(){
    if(player.iFrames>0) return;
    player.iFrames=1.1;
    player.lives=Math.max(0, player.lives-1);

    if(player.lives===2){
      const old=pH(); player.stage=1; player.y += (old-pH());
    }else if(player.lives===1){
      const old=pH(); player.stage=2; player.y += (old-pH());
    }else{
      resetGame();
      return;
    }
    player.vx = -260;
  }

  function handleHits(){
    if(flagTriggered) return;
    const pw=pW(), ph=pH();

    for(const o of obstacles){
      if(!aabb(player.x,player.y,pw,ph, o.x,o.y,o.w,o.h)) continue;

      const bottom = player.y + ph;
      const overlapTop = bottom - o.y;
      const topHit = player.vy > 140 && overlapTop >= 0 && overlapTop <= 34;

      if(topHit){
        boom(o.x+o.w/2, o.y);
        score += 3;
        // remove obstacle
        const idx = obstacles.indexOf(o);
        if(idx>=0) obstacles.splice(idx,1);
        activeNames.delete(o.name);
        player.vy = -650;
      }else{
        takeHit();
      }
      break;
    }
  }

  // ---------- Drawing helpers ----------
  function roundRect(x,y,w,h,r){
    const rr=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function setScale(){
    const cw = window.innerWidth;
    const ch = window.innerHeight;
    const s = Math.min(cw/BASE_W, ch/BASE_H);
    ctx.setTransform(s,0,0,s, (cw - BASE_W*s)/2, (ch - BASE_H*s)/2);
    ctx.imageSmoothingEnabled=false;
  }

  function drawBackground(){
    // sky->sea->ground bands
    const g = ctx.createLinearGradient(0,0,0,BASE_H);
    g.addColorStop(0, "#6bb6ff");
    g.addColorStop(0.50, "#bfe6ff");
    g.addColorStop(0.505, "#7bdc6f");
    g.addColorStop(1, "#49b85a");
    ctx.fillStyle=g;
    ctx.fillRect(0,0,BASE_W,BASE_H);

    // sea label (right)
    ctx.globalAlpha=0.88;
    ctx.fillStyle="rgba(0,40,90,.35)";
    ctx.fillRect(0,92,BASE_W,44);
    ctx.fillStyle="rgba(255,255,255,.92)";
    ctx.font="1000 22px system-ui";
    ctx.fillText("Ege körfez sahil", 18, 122);
    ctx.globalAlpha=1;
  }

  function drawTiles(){
    const startTx=Math.floor(cam.x/TILE);
    const endTx=Math.ceil((cam.x+BASE_W)/TILE);
    for(let ty=0;ty<MAP_H;ty++){
      for(let tx=startTx;tx<=endTx;tx++){
        if(tileAt(tx,ty)!==1) continue;
        const x=tx*TILE - cam.x;
        const y=ty*TILE - cam.y;
        const ground = (ty>=MAP_H-2);
        ctx.fillStyle = ground ? "rgba(40,120,60,1)" : "rgba(165,105,60,1)";
        ctx.fillRect(x,y,TILE,TILE);
        ctx.strokeStyle="rgba(0,0,0,.18)";
        ctx.strokeRect(x+0.5,y+0.5,TILE-1,TILE-1);
      }
    }
  }

  function label(wx,wy,text){
    const sx=wx-cam.x, sy=wy-cam.y;
    if(sx<-400||sx>BASE_W+400) return;
    ctx.font="1000 16px system-ui";
    const tw=ctx.measureText(text).width;
    ctx.globalAlpha=0.92;
    ctx.fillStyle="rgba(0,0,0,.35)";
    ctx.fillRect(sx-6, sy-22, tw+12, 28);
    ctx.fillStyle="#fff";
    ctx.fillText(text, sx, sy-2);
    ctx.globalAlpha=1;
  }

  function drawLandmarks(){
    label(14*TILE,  (MAP_H-4)*TILE,   "Bornova ovası");
    label(34*TILE,  (MAP_H-2-5)*TILE, "Bayraklı üst geçit");
    label(58*TILE,  (MAP_H-2-3)*TILE, "Karşıyaka otoban girişi");
    label(84*TILE,  (MAP_H-2-4)*TILE, "Alaybey girişi");
    label(104*TILE, (MAP_H-2-2)*TILE, "Karşıyaka");
  }

  function drawFlagLine(){
    const x = FLAG_LINE_X - cam.x;
    if(x<-60||x>BASE_W+60) return;
    ctx.save();
    ctx.globalAlpha=0.88;
    ctx.strokeStyle="rgba(255,255,255,.95)";
    ctx.lineWidth=4;
    ctx.setLineDash([12,12]);
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,BASE_H); ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  function drawNameBig(cx, topY, text){
    ctx.save();
    ctx.font="1000 22px system-ui";
    const tw=ctx.measureText(text).width;
    ctx.globalAlpha=0.98;
    ctx.fillStyle="rgba(0,0,0,.55)";
    ctx.fillRect(cx - tw/2 - 12, topY - 36, tw + 24, 30);
    ctx.fillStyle="#fff";
    ctx.fillText(text, cx - tw/2, topY - 14);
    ctx.restore();
  }

  // Simple character drawing (stylized)
  function drawPerson(x,y,w,h, hair, body, skin, mustache=false, slanted=false){
    // hair
    ctx.fillStyle=hair;
    ctx.beginPath(); ctx.ellipse(x+w*0.5,y+h*0.20,w*0.36,h*0.26,0,0,Math.PI*2); ctx.fill();
    // face
    ctx.fillStyle=skin;
    ctx.beginPath(); ctx.ellipse(x+w*0.5,y+h*0.32,w*0.24,h*0.20,0,0,Math.PI*2); ctx.fill();
    // eyes
    ctx.strokeStyle="rgba(20,20,20,.9)"; ctx.lineWidth=3;
    const ey=y+h*0.32;
    if(!slanted){
      ctx.beginPath(); ctx.moveTo(x+w*0.40,ey); ctx.lineTo(x+w*0.46,ey); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x+w*0.54,ey); ctx.lineTo(x+w*0.60,ey); ctx.stroke();
    }else{
      ctx.beginPath(); ctx.moveTo(x+w*0.39,ey+4); ctx.lineTo(x+w*0.48,ey-4); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x+w*0.52,ey-4); ctx.lineTo(x+w*0.61,ey+4); ctx.stroke();
    }
    if(mustache){
      ctx.beginPath(); ctx.moveTo(x+w*0.44,y+h*0.40); ctx.lineTo(x+w*0.33,y+h*0.42); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x+w*0.56,y+h*0.40); ctx.lineTo(x+w*0.67,y+h*0.42); ctx.stroke();
    }
    // body
    ctx.fillStyle=body;
    roundRect(x+w*0.28,y+h*0.46,w*0.44,h*0.50,18); ctx.fill();
  }

  function drawObstacle(o){
    const x=o.x-cam.x, y=o.y-cam.y;

    // shadow
    ctx.fillStyle="rgba(0,0,0,.16)";
    ctx.beginPath(); ctx.ellipse(x+o.w/2, y+o.h+14, o.w*0.45, 9, 0, 0, Math.PI*2); ctx.fill();

    if(o.kind==="car"){
      ctx.fillStyle="rgba(40,90,180,1)";
      roundRect(x, y+o.h*0.25, o.w, o.h*0.55, 18); ctx.fill();
      ctx.fillStyle="rgba(55,120,210,1)";
      roundRect(x+o.w*0.15, y, o.w*0.55, o.h*0.42, 18); ctx.fill();
      ctx.fillStyle="rgba(170,230,255,.85)";
      roundRect(x+o.w*0.25, y+o.h*0.12, o.w*0.38, o.h*0.20, 14); ctx.fill();
      ctx.fillStyle="rgba(20,20,20,1)";
      ctx.beginPath(); ctx.arc(x+o.w*0.24,y+o.h*0.90,12,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(x+o.w*0.76,y+o.h*0.90,12,0,Math.PI*2); ctx.fill();
    } else if(o.kind==="uno_card"){
      ctx.save();
      ctx.translate(x+o.w/2, y+o.h/2);
      ctx.rotate(o.spin);
      ctx.translate(-o.w/2, -o.h/2);
      ctx.fillStyle="rgba(200,30,40,1)";
      roundRect(0,0,o.w,o.h,18); ctx.fill();
      ctx.fillStyle="rgba(255,255,255,.95)";
      ctx.font="1000 28px system-ui";
      ctx.fillText("UNO", 16, o.h*0.66);
      ctx.restore();
    } else if(o.kind==="beer"){
      // zigzag trail
      ctx.save();
      ctx.globalAlpha=0.55;
      ctx.strokeStyle="rgba(255,255,255,.9)";
      ctx.lineWidth=3;
      ctx.beginPath();
      const steps=8;
      for(let i=0;i<=steps;i++){
        const px = x + i*(o.w/steps);
        const py = y + o.h*0.48 + Math.sin(o.t*o.zigFreq + i*0.9) * 14;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.restore();

      ctx.fillStyle="rgba(255,255,255,.85)";
      roundRect(x+o.w*0.22,y+o.h*0.18,o.w*0.52,o.h*0.72,18); ctx.fill();
      ctx.fillStyle="rgba(255,190,40,.95)";
      roundRect(x+o.w*0.24,y+o.h*0.34,o.w*0.48,o.h*0.54,16); ctx.fill();
      ctx.strokeStyle="rgba(255,255,255,.85)";
      ctx.lineWidth=10;
      ctx.beginPath();
      ctx.arc(x+o.w*0.78,y+o.h*0.55,o.w*0.12,-Math.PI/2,Math.PI/2);
      ctx.stroke();
    } else if(o.kind==="flower"){
      const cx=x+o.w*0.52, cy=y+o.h*0.48;
      ctx.save(); ctx.translate(cx,cy);
      ctx.fillStyle="rgba(255,200,0,.95)";
      for(let i=0;i<6;i++){
        ctx.rotate(Math.PI/3);
        ctx.beginPath(); ctx.ellipse(0,-o.h*0.22,o.w*0.12,o.h*0.18,0,0,Math.PI*2); ctx.fill();
      }
      ctx.fillStyle="rgba(255,80,80,.95)";
      ctx.beginPath(); ctx.arc(0,0,Math.min(o.w,o.h)*0.13,0,Math.PI*2); ctx.fill();
      ctx.restore();
      ctx.fillStyle="rgba(30,130,70,.95)";
      ctx.fillRect(x+o.w*0.48,y+o.h*0.40,o.w*0.06,o.h*0.60);
    } else if(o.kind==="angel"){
      ctx.fillStyle="rgba(255,255,255,.92)";
      ctx.beginPath();
      ctx.ellipse(x+o.w*0.30,y+o.h*0.52,o.w*0.22,o.h*0.20,-0.4,0,Math.PI*2);
      ctx.ellipse(x+o.w*0.70,y+o.h*0.52,o.w*0.22,o.h*0.20,0.4,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle="rgba(255,230,120,.95)";
      ctx.lineWidth=6;
      ctx.beginPath(); ctx.ellipse(x+o.w*0.50,y+o.h*0.18,o.w*0.18,o.h*0.10,0,0,Math.PI*2); ctx.stroke();
      drawPerson(x,y,o.w,o.h,"rgba(250,225,95,1)","rgba(240,240,255,1)","rgba(255,225,200,1)",false,false);
    } else if(o.kind==="girl_piano"){
      drawPerson(x,y,o.w*0.55,o.h,"rgba(250,220,80,1)","rgba(250,120,70,1)","rgba(255,225,200,1)",false,false);
      ctx.fillStyle="rgba(20,20,25,1)";
      roundRect(x+o.w*0.50,y+o.h*0.60,o.w*0.48,o.h*0.30,14); ctx.fill();
    } else if(o.kind==="man_laptop"){
      drawPerson(x,y,o.w*0.55,o.h,"rgba(40,25,15,1)","rgba(60,160,120,1)","rgba(255,220,195,1)",false,false);
      ctx.fillStyle="rgba(30,30,35,1)";
      roundRect(x+o.w*0.52,y+o.h*0.64,o.w*0.44,o.h*0.22,12); ctx.fill();
    } else if(o.kind==="tall_black_girl"){
      drawPerson(x,y,o.w,o.h,"rgba(10,10,10,1)","rgba(40,40,80,1)","rgba(145,95,70,1)",false,false);
    } else if(o.kind==="slanted_girl"){
      drawPerson(x,y,o.w,o.h,"rgba(25,20,15,1)","rgba(230,90,150,1)","rgba(255,225,205,1)",false,true);
    } else if(o.kind==="blond_mustache_man"){
      drawPerson(x,y,o.w,o.h,"rgba(245,215,60,1)","rgba(80,120,200,1)","rgba(255,225,200,1)",true,false);
    } else if(o.kind==="hairy_man"){
      drawPerson(x,y,o.w,o.h,"rgba(40,25,15,1)","rgba(60,160,120,1)","rgba(255,220,195,1)",false,false);
    } else if(o.kind==="bald_mustache_man"){
      drawPerson(x,y,o.w,o.h,"rgba(0,0,0,0)","rgba(140,80,170,1)","rgba(255,225,200,1)",true,false);
    } else if(o.kind==="blonde_girl"){
      drawPerson(x,y,o.w,o.h,"rgba(250,220,80,1)","rgba(250,120,70,1)","rgba(255,225,200,1)",false,false);
    }

    drawNameBig(x+o.w/2, y, o.name);
  }

  function drawFX(){
    for(const f of fx){
      const a = clamp(1 - f.t/f.life, 0, 1);
      const sx=f.x-cam.x, sy=f.y-cam.y;

      ctx.save();
      ctx.globalAlpha=0.95*a;
      ctx.fillStyle="rgba(0,0,0,.42)";
      roundRect(sx-80, sy-90, 160, 50, 16); ctx.fill();
      ctx.fillStyle="#fff";
      ctx.font="1000 30px system-ui";
      ctx.fillText("BOOM", sx-54, sy-56);
      ctx.restore();

      for(const p of f.sparks){
        const px=sx+p.x, py=sy+p.y;
        const hot=clamp(1 - f.t/f.life, 0, 1);
        ctx.save();
        ctx.globalAlpha=0.85*a;
        ctx.fillStyle=`rgba(255,${Math.floor(150+hot*90)},${Math.floor(30+hot*50)},1)`;
        ctx.beginPath(); ctx.arc(px,py,p.r,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }
  }

  function drawPlayer(){
    const w=pW(), h=pH();
    const x=player.x-cam.x, y=player.y-cam.y;

    // blink during iFrames
    if(player.iFrames>0 && (Math.floor(performance.now()/80)%2===0)) return;

    // shadow
    ctx.fillStyle="rgba(0,0,0,.18)";
    ctx.beginPath(); ctx.ellipse(x+w/2, y+h+10, w*0.55, 10, 0, 0, Math.PI*2); ctx.fill();

    // body suit
    ctx.fillStyle="rgba(30,40,55,1)";
    roundRect(x+3, y+Math.max(18,h*0.28), w-6, h*0.72, 18); ctx.fill();

    // white shirt
    ctx.fillStyle="rgba(245,245,245,1)";
    roundRect(x+4, y+Math.max(30,h*0.55), w-8, h*0.45, 18); ctx.fill();

    // face
    ctx.fillStyle="rgba(255,225,200,1)";
    ctx.beginPath(); ctx.ellipse(x+w/2, y+22, w*0.22, h*0.18, 0, 0, Math.PI*2); ctx.fill();

    // eyes
    ctx.strokeStyle="rgba(20,20,20,.95)"; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(x+w/2-6, y+24); ctx.lineTo(x+w/2-20, y+26); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+w/2+6, y+24); ctx.lineTo(x+w/2+20, y+26); ctx.stroke();

    // green cap
    ctx.fillStyle="rgba(50,170,90,1)";
    roundRect(x-3, y+6, w+6, h*0.14, 16); ctx.fill();
    ctx.fillStyle="rgba(40,140,75,1)";
    roundRect(x+4, y-10, w-8, h*0.11, 16); ctx.fill();
  }

  function drawCastle(){
    const sx=castle.x-cam.x;
    const sy=(MAP_H-2)*TILE - castle.h;

    ctx.fillStyle="rgba(170,150,120,1)";
    roundRect(sx,sy,castle.w,castle.h,22); ctx.fill();

    // label
    ctx.fillStyle="rgba(0,0,0,.45)";
    roundRect(sx+castle.w*0.12, sy+16, castle.w*0.76, 52, 14); ctx.fill();
    ctx.fillStyle="#fff";
    ctx.font="1000 26px system-ui";
    ctx.fillText("Дом Алёны", sx+castle.w*0.30, sy+52);

    // pole
    const px=pole.x-cam.x;
    ctx.strokeStyle="rgba(40,40,40,.9)";
    ctx.lineWidth=8;
    ctx.beginPath();
    ctx.moveTo(px, pole.topY - cam.y);
    ctx.lineTo(px, pole.bottomY - cam.y);
    ctx.stroke();

    // flag
    ctx.fillStyle="rgba(240,60,60,.95)";
    ctx.beginPath();
    ctx.moveTo(px, pole.topY - cam.y + 22);
    ctx.lineTo(px+64, pole.topY - cam.y + 40);
    ctx.lineTo(px, pole.topY - cam.y + 58);
    ctx.closePath();
    ctx.fill();

    // Big Alena in cutscene/gameOver
    if(cutscene || gameOver){
      const ax = sx+castle.w*0.86, ay = sy+castle.h*0.88;
      // hair
      ctx.fillStyle="rgba(250,225,95,1)";
      ctx.beginPath(); ctx.ellipse(ax, ay-150, 74, 54, 0, 0, Math.PI*2); ctx.fill();
      // face
      ctx.fillStyle="rgba(255,225,200,1)";
      ctx.beginPath(); ctx.ellipse(ax, ay-138, 30, 30, 0, 0, Math.PI*2); ctx.fill();
      // eyes
      ctx.strokeStyle="rgba(25,25,25,.95)";
      ctx.lineWidth=4;
      ctx.beginPath(); ctx.moveTo(ax-16, ay-140); ctx.lineTo(ax-6, ay-140); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ax+6, ay-140); ctx.lineTo(ax+16, ay-140); ctx.stroke();
      // dress
      ctx.fillStyle="rgba(255,255,255,.97)";
      roundRect(ax-60, ay-106, 120, 150, 30); ctx.fill();
      // belt
      ctx.fillStyle="rgba(255,210,60,1)";
      roundRect(ax-46, ay-32, 92, 16, 12); ctx.fill();
    }
  }

  // ---------- Main update/draw ----------
  function update(dt){
    if(gameOver) return;

    // iFrames
    if(player.iFrames>0) player.iFrames = Math.max(0, player.iFrames-dt);

    // cutscene: after flag line, obstacles freeze, player walks to castle
    if(cutscene){
      player.vx = 220;
      player.vy += GRAV*dt;
      collide(dt);

      // camera
      cam.x = clamp(player.x + pW()/2 - BASE_W*0.40, 0, WORLD_W-BASE_W);
      cam.y = 0;

      if(player.x > castle.x - 140){
        player.vx=0;
        gameOver=true;
      }

      updateFX(dt);
      hudText.textContent = `Счёт: ${score} • ${hearts()}`;
      return;
    }

    time += dt;

    // spawn
    if(!flagTriggered && player.x < STOP_OBS_X){
      spawnTimer += dt;
      if(spawnTimer >= 3.0){
        spawnTimer = 0;
        spawnWave(time);
      }
      updateObstacles(dt);
    }

    // jump
    if(jumpQueued && player.onGround){
      player.vy = -pJump();
      player.onGround=false;
    }
    jumpQueued=false;

    // movement
    autoRun(dt);
    player.vy += GRAV*dt;
    collide(dt);

    // camera
    cam.x = clamp(player.x + pW()/2 - BASE_W*0.40, 0, WORLD_W-BASE_W);
    cam.y = 0;

    // obstacle extra props
    for(const o of obstacles){
      if(o.motion==="spin") o.spin += dt*6.2;
    }

    handleHits();
    updateFX(dt);

    // flag line trigger
    if(!flagTriggered && (player.x + pW() >= FLAG_LINE_X)){
      flagTriggered=true;
      overlay.style.display="flex";
      finalScore.textContent = `Счёт: ${score}`;
      cutscene=true; // start walk to castle
    }

    hudText.textContent = `Счёт: ${score} • ${hearts()}`;
  }

  function draw(){
    setScale();
    ctx.clearRect(-2000,-2000,5000,5000);

    drawBackground();
    drawTiles();
    drawLandmarks();
    drawFlagLine();

    // obstacles
    for(const o of obstacles) drawObstacle(o);

    drawFX();
    drawCastle();
    drawPlayer();
  }

  // ---------- Reset ----------
  function resetGame(){
    score=0; time=0; spawnTimer=0; spawnIndex=0;
    flagTriggered=false; cutscene=false; gameOver=false;
    overlay.style.display="none";

    player.x=70; player.y=0; player.vx=0; player.vy=0; player.onGround=false;
    player.stage=0; player.lives=3; player.iFrames=0;

    obstacles.length=0;
    activeNames.clear();
    lastSpawn.clear();
    fx.length=0;
    cam.x=0; cam.y=0;

    hudText.textContent = `Счёт: 0 • ${hearts()}`;
  }

  // ---------- Loop ----------
  let last=performance.now();
  function loop(now){
    const dt=Math.min(0.033,(now-last)/1000);
    last=now;
    if(running){
      update(dt);
      draw();
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ---------- Buttons ----------
  startBtn.addEventListener("click", async ()=>{
    await tryFullscreen();
    menu.style.display="none";
    gameWrap.style.display="block";
    running=true;
    resetGame();
  });

  backBtn.addEventListener("click", ()=>{
    running=false;
    gameWrap.style.display="none";
    menu.style.display="flex";
  });

  restartBtn.addEventListener("click", resetGame);

})();
</script>
</body>
</html>
