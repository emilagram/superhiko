<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Super Hiko — vs. Friends</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel: rgba(17,26,46,.92);
      --line: rgba(255,255,255,.14);
      --text:#e8eefc;
    }
    html, body { height: 100%; margin: 0; background:var(--bg); color:var(--text); font-family: system-ui, Arial; }
    .wrap { display:flex; flex-direction:column; align-items:center; gap:10px; padding:14px; }

    /* START SCREEN */
    .start-screen{
      width:min(980px, 95vw);
      border:1px solid var(--line);
      background:var(--panel);
      border-radius:16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      padding:18px;
    }
    .title{
      font-weight:900;
      font-size:30px;
      margin:0 0 8px 0;
      letter-spacing:.3px;
    }
    .sub{
      margin:0 0 14px 0;
      opacity:.92;
      line-height:1.35;
      font-size:14px;
    }
    .list{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap:10px;
      margin: 12px 0 16px;
    }
    .chip{
      border:1px solid var(--line);
      border-radius:12px;
      padding:10px 12px;
      background:rgba(255,255,255,.04);
      font-weight:800;
    }
    .go{
      display:block;
      width:100%;
      font-weight:950;
      font-size:20px;
      padding:14px 16px;
      border-radius:14px;
      cursor:pointer;
      border:1px solid rgba(255,255,255,.2);
      background: linear-gradient(135deg, rgba(80,180,120,.95), rgba(70,120,220,.95));
      color:#fff;
      box-shadow: 0 10px 25px rgba(0,0,0,.30);
    }
    .go:hover{ filter:brightness(1.06); }

    /* HUD + Canvas */
    .hud{
      width:min(980px, 95vw);
      display:flex; justify-content:space-between; align-items:center;
      font-size:14px; opacity:.96;
    }
    kbd{
      background:#111a2e; border:1px solid rgba(255,255,255,.12);
      padding:2px 6px; border-radius:6px; font-size:12px;
    }
    .btns{display:flex; gap:8px; align-items:center}
    button{
      background:#111a2e; color:#e8eefc;
      border:1px solid rgba(255,255,255,.15);
      padding:8px 10px; border-radius:10px; cursor:pointer;
    }
    button:hover{filter:brightness(1.1)}
    canvas {
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      background: linear-gradient(#6bb6ff, #bfe6ff 55%, #7bdc6f 55%, #49b85a);
      image-rendering: pixelated;
      display:none;
    }
    .hidden{ display:none !important; }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- START -->
    <div id="startScreen" class="start-screen">
      <h1 class="title">Super Hiko vs. Friends</h1>
      <p class="sub">
        Цель: добраться до <b>дома Алёны</b> (замок) и поймать флаг.
        <br/>Управление: <kbd>←</kbd><kbd>→</kbd> — движение, <kbd>↑</kbd>/<kbd>Space</kbd> — прыжок, <kbd>R</kbd> — перезапуск.
      </p>

      <div id="enemyList" class="list"></div>

      <button id="goBtn" class="go">ПОЕХАЛИ К ДОМУ АЛЁНЫ</button>
    </div>

    <!-- HUD -->
    <div id="hud" class="hud hidden">
      <div>
        <b>Super Hiko</b> —
        <kbd>←</kbd><kbd>→</kbd> движение,
        <kbd>↑</kbd>/<kbd>Space</kbd> прыжок,
        <kbd>R</kbd> рестарт
      </div>
      <div class="btns">
        <div id="info"></div>
        <button id="resetBtn">Рестарт</button>
      </div>
    </div>

    <canvas id="game" width="980" height="540"></canvas>
  </div>

<script>
(() => {
  "use strict";

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;

  // === Friends list + patterns ===
  // 3 saniye farkla, her biri farklı yerden girer (spawnPoint),
  // farklı hareket modları: zigzag, dive, float, drift, wobble, dash...
  const friends = [
    {name:"Zloy Stas", kind:"blond_mustache_man", lane:"air",   speed:260, size:"m", spawnPoint:"topRight",    motion:"dash"},
    {name:"Arkadağ", kind:"hairy_man",           lane:"ground",speed:200, size:"m", spawnPoint:"right",       motion:"steady"},
    {name:"Timur Niva", kind:"car",              lane:"ground",speed:300, size:"xl",spawnPoint:"right",       motion:"bump"},
    {name:"Mona", kind:"slanted_eyes_girl",      lane:"mid",   speed:230, size:"l", spawnPoint:"midRight",    motion:"wobble"},
    {name:"Emil Abi", kind:"bald_mustache_man",  lane:"ground",speed:220, size:"l", spawnPoint:"right",       motion:"steady"},
    {name:"Uno", kind:"uno_card",                lane:"mid",   speed:280, size:"l", spawnPoint:"topRight",    motion:"spin"},
    {name:"Asya", kind:"blonde_girl",            lane:"ground",speed:205, size:"m", spawnPoint:"right",       motion:"steady"},
    // Aynura: havadan "düşerek" gelsin (dive)
    {name:"Aynura", kind:"tall_black_girl",      lane:"air",   speed:240, size:"xl",spawnPoint:"topRight",    motion:"dive"},
    {name:"Zamina", kind:"girl_piano",           lane:"ground",speed:190, size:"xl",spawnPoint:"right",       motion:"heavy"},
    {name:"Elnur", kind:"man_laptop",            lane:"air",   speed:235, size:"xl",spawnPoint:"topRight",    motion:"drift"},
    {name:"Angelina Minsk", kind:"flower",       lane:"air",   speed:185, size:"m", spawnPoint:"topRight",    motion:"float"},
    {name:"Malika", kind:"angel",                lane:"air",   speed:180, size:"l", spawnPoint:"topRight",    motion:"float"},
    // Aşkiyom: bira bardağı + çizerek zikzak
    {name:"Aşkiyom", kind:"beer",                lane:"mid",   speed:210, size:"l", spawnPoint:"midRight",    motion:"zigzag"},
  ];

  // Start screen list (RU)
  const enemyListEl = document.getElementById("enemyList");
  friends.forEach(e => {
    const d = document.createElement("div");
    d.className = "chip";
    d.textContent = e.name;
    enemyListEl.appendChild(d);
  });

  const startScreen = document.getElementById("startScreen");
  const hud = document.getElementById("hud");
  const goBtn = document.getElementById("goBtn");

  // === World ===
  const TILE = 32;
  const MAP_W = 210;
  const MAP_H = 18;
  const worldPxW = MAP_W * TILE;
  const worldPxH = MAP_H * TILE;

  const map = Array.from({length: MAP_H}, () => Array(MAP_W).fill(0));
  for (let x = 0; x < MAP_W; x++) { map[MAP_H-1][x] = 1; map[MAP_H-2][x] = 1; }

  const putRect = (tx, ty, tw, th, v=1) => {
    for (let y = ty; y < ty+th; y++) for (let x = tx; x < tx+tw; x++) {
      if (y>=0 && y<MAP_H && x>=0 && x<MAP_W) map[y][x] = v;
    }
  };

  // Path landmarks
  putRect(14, MAP_H-4, 10, 2, 1);            // Bornova ovası
  putRect(34, MAP_H-2-5, 10, 5, 1);          // Bayraklı üst geçit
  putRect(58, MAP_H-2-3, 12, 3, 1);          // Karşıyaka otoban girişi
  putRect(84, MAP_H-2-4, 12, 4, 1);          // Alaybey girişi
  putRect(104, MAP_H-2-2, 14, 2, 1);         // Karşıyaka

  // Stop zone + castle
  const LAST_RISE_TX = 132;
  putRect(LAST_RISE_TX, MAP_H-2-3, 10, 3, 1);

  const SAFE_WALK_START_TX = LAST_RISE_TX + 10;
  putRect(SAFE_WALK_START_TX, MAP_H-2-2, 3, 2, 1);

  const CASTLE_TX = SAFE_WALK_START_TX + 3;
  putRect(CASTLE_TX, MAP_H-6, 20, 1, 1);

  const FLAG_TX = CASTLE_TX + 15;
  const POLE_TX = CASTLE_TX + 17;
  putRect(POLE_TX, MAP_H-10, 1, 8, 1);

  const STOP_OBSTACLES_X = (LAST_RISE_TX * TILE) - 40;

  // === Player (3 lives / 3 sizes) ===
  const stages = [
    {name:"Super Hiko", w: 34, h: 48, jump: 1000},
    {name:"Midi Hiko",  w: 28, h: 38, jump: 980},
    {name:"Mini Hiko",  w: 24, h: 30, jump: 960},
  ];
  const player = { x:70,y:0, vx:0,vy:0, onGround:false, face:1, stage:0, lives:3, iFrames:0 };

  const GRAV = 1850;
  const MOVE_ACC = 3000;
  const MAX_VX = 420;
  const FRICTION = 0.82;
  const AIR_DRAG = 0.97;

  const cam = { x:0, y:0 };

  // Input
  const keys = new Set();
  addEventListener("keydown",(e)=>{
    if (["ArrowLeft","ArrowRight","ArrowUp","Space","KeyR"].includes(e.code)) e.preventDefault();
    keys.add(e.code);
    if (e.code==="KeyR") reset();
  });
  addEventListener("keyup",(e)=>keys.delete(e.code));
  document.getElementById("resetBtn").addEventListener("click", reset);

  // Game state
  let started=false, gameOver=false, cutscene=false;
  let score=0;

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const tileAt=(tx,ty)=> (tx<0||ty<0||tx>=MAP_W||ty>=MAP_H)?0:map[ty][tx];
  const aabb=(ax,ay,aw,ah,bx,by,bw,bh)=> ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;

  function getStage(){ return stages[player.stage]; }
  function pW(){ return getStage().w; }
  function pH(){ return getStage().h; }
  function pJump(){ return getStage().jump; }

  function getSolidTilesOverlapping(x,y,w,h){
    const left=Math.floor(x/TILE), right=Math.floor((x+w)/TILE);
    const top=Math.floor(y/TILE), bottom=Math.floor((y+h)/TILE);
    const tiles=[];
    for(let ty=top; ty<=bottom; ty++) for(let tx=left; tx<=right; tx++){
      if (tileAt(tx,ty)===1) tiles.push({tx,ty});
    }
    return tiles;
  }

  function collideAndSlide(dt){
    const w=pW(), h=pH();
    player.onGround=false;

    // X
    player.x += player.vx*dt;
    for(const t of getSolidTilesOverlapping(player.x,player.y,w,h)){
      const rx=t.tx*TILE, ry=t.ty*TILE;
      if(aabb(player.x,player.y,w,h, rx,ry,TILE,TILE)){
        if(player.vx>0) player.x = rx-w;
        else if(player.vx<0) player.x = rx+TILE;
        player.vx=0;
      }
    }

    // Y
    player.y += player.vy*dt;
    for(const t of getSolidTilesOverlapping(player.x,player.y,w,h)){
      const rx=t.tx*TILE, ry=t.ty*TILE;
      if(aabb(player.x,player.y,w,h, rx,ry,TILE,TILE)){
        if(player.vy>0){
          player.y = ry-h;
          player.vy=0;
          player.onGround=true;
        }else if(player.vy<0){
          player.y = ry+TILE;
          player.vy=0;
        }
      }
    }

    player.x = clamp(player.x, 0, worldPxW - w);
    if (player.y > worldPxH) reset();
  }

  // === Obstacles system ===
  const obstacles=[];
  let timeSinceStart=0;

  // spawn cycle: every 3 seconds, next friend spawns.
  // Each friend can re-spawn after 10 seconds (cooldown).
  let spawnIndex=0;
  let spawnTimer=0;
  const lastSpawnByName = new Map(); // name -> time
  const activeNames = new Set();

  function sizeFor(friend){
    const s = friend.size;
    if (friend.kind==="car") return {w:78,h:48};
    if (friend.kind==="tall_black_girl") return {w:54,h:84};
    if (friend.kind==="girl_piano") return {w:78,h:56};
    if (friend.kind==="man_laptop") return {w:70,h:56};
    if (friend.kind==="uno_card") return {w:56,h:74};
    if (friend.kind==="beer") return {w:58,h:82};
    if (s==="xl") return {w:74,h:70};
    if (s==="l")  return {w:64,h:64};
    return {w:58,h:60};
  }

  function laneY(friend, h){
    const groundY = (MAP_H-2)*TILE;
    if (friend.lane==="ground") return groundY - h;
    if (friend.lane==="mid") return groundY - h - (80 + Math.random()*35);
    return groundY - h - (145 + Math.random()*80);
  }

  function spawnPointXY(spawnPoint){
    // "sayfanın farklı yeri" -> farklı giriş noktaları
    const x = cam.x + W + 120;
    let y = 120;
    if (spawnPoint==="right") y = (MAP_H-2)*TILE - 200;
    if (spawnPoint==="midRight") y = 220;
    if (spawnPoint==="topRight") y = 90;
    return {x, y};
  }

  function canSpawn(friend){
    if (activeNames.has(friend.name)) return false;
    const last = lastSpawnByName.get(friend.name) ?? -9999;
    return (timeSinceStart - last) >= 10;
  }

  function addObstacle(friend){
    const sz = sizeFor(friend);
    const sp = spawnPointXY(friend.spawnPoint);
    const baseY = laneY(friend, sz.h);

    const o = {
      name: friend.name,
      kind: friend.kind,
      lane: friend.lane,
      motion: friend.motion,
      x: sp.x,
      y: (friend.spawnPoint==="right") ? baseY : Math.min(baseY, sp.y + 80),
      baseY,
      w: sz.w, h: sz.h,
      vx: -friend.speed,
      vy: 0,
      t: 0,
      // motion params
      zigAmp: 38 + Math.random()*18,
      zigFreq: 2.2 + Math.random()*1.0,
      driftAmp: 70 + Math.random()*40,
      spin: 0
    };

    // Aynura dive: üstten girip yere düşsün
    if (o.motion==="dive"){
      o.y = (pole.topY - 180) + (Math.random()*40);
      o.vy = 0;
    }

    // Angelina/Malika float: daha yukarıdan başlasın
    if (o.motion==="float"){
      o.y = baseY - (60 + Math.random()*60);
    }

    obstacles.push(o);
    activeNames.add(o.name);
    lastSpawnByName.set(o.name, timeSinceStart);
  }

  function removeObstacle(o){
    const i = obstacles.indexOf(o);
    if (i>=0) obstacles.splice(i,1);
    activeNames.delete(o.name);
  }

  function updateSpawns(dt){
    if (player.x > STOP_OBSTACLES_X) return;

    spawnTimer += dt;

    // every 3 sec spawn next possible friend (wrap around)
    while (spawnTimer >= 3.0){
      spawnTimer -= 3.0;

      let tries = 0;
      while (tries < friends.length){
        const f = friends[spawnIndex % friends.length];
        spawnIndex++;
        tries++;
        if (canSpawn(f)){
          addObstacle(f);
          break;
        }
      }
    }
  }

  function updateObstacles(dt){
    if (player.x > STOP_OBSTACLES_X) return;

    for (const o of obstacles){
      o.t += dt;

      // base move
      o.x += o.vx * dt;

      // motion behaviors (spontaneous)
      if (o.motion==="zigzag"){
        // Aşkiyom beer: draw zigzag path by moving up/down strongly
        o.y = o.baseY + Math.sin(o.t * o.zigFreq) * o.zigAmp;
      }
      else if (o.motion==="float"){
        o.y = o.baseY + Math.sin(o.t*3.4) * 22;
        // sometimes slow down / speed up a bit
        const pulse = 0.75 + 0.25*Math.sin(o.t*1.1);
        o.x += (o.vx * (pulse-1)) * dt;
      }
      else if (o.motion==="dive"){
        // Aynura: falls down then stabilizes near baseY
        o.vy += 1200 * dt;
        o.y += o.vy * dt;
        if (o.y > o.baseY){
          o.y = o.baseY;
          o.vy = 0;
          // after landing, slight wobble
          o.y = o.baseY + Math.sin(o.t*2.6) * 8;
        }
      }
      else if (o.motion==="drift"){
        // Elnur: drifting diagonal
        o.y = o.baseY + Math.sin(o.t*2.0) * 18;
        o.x += Math.sin(o.t*1.6) * 12 * dt;
      }
      else if (o.motion==="wobble"){
        o.y = o.baseY + Math.sin(o.t*2.8) * 16;
      }
      else if (o.motion==="spin"){
        o.spin += dt*6.5;
        o.y = o.baseY + Math.sin(o.t*2.4) * 14;
      }
      else if (o.motion==="bump"){
        o.y = o.baseY + Math.abs(Math.sin(o.t*3.2)) * -8;
      }
      else if (o.motion==="heavy"){
        // Zamina heavy: small stops
        const stop = (Math.sin(o.t*1.2) > 0.85) ? 0.2 : 1.0;
        o.x += o.vx * dt * (stop-1);
        o.y = o.baseY;
      }
      else if (o.motion==="dash"){
        // Zloy Stas: slight dashes
        const dash = 0.85 + 0.35*Math.max(0, Math.sin(o.t*2.0));
        o.x += o.vx * dt * (dash-1);
        o.y = o.baseY + Math.sin(o.t*3.0) * 10;
      }
      else {
        o.y = o.baseY;
      }
    }

    // cleanup offscreen
    for (let i=obstacles.length-1; i>=0; i--){
      const o = obstacles[i];
      if (o.x < cam.x - 300){
        removeObstacle(o);
      }
    }
  }

  // === BOOM FX ===
  const fxList=[];
  function roundRect(x,y,w,h,r,fill,stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }
  function spawnBoom(x,y){
    const f={x,y,t:0,life:0.6,sparks:[]};
    for(let i=0;i<26;i++){
      f.sparks.push({x:0,y:0,vx:(Math.random()*2-1)*(170+Math.random()*140),vy:-(150+Math.random()*260),r:2.5+Math.random()*3.5});
    }
    fxList.push(f);
  }
  function updateFX(dt){
    for(const f of fxList){
      f.t += dt;
      for(const p of f.sparks){
        p.vy += 980*dt;
        p.x += p.vx*dt;
        p.y += p.vy*dt;
        p.vx *= Math.pow(0.96, dt*60);
      }
    }
    for(let i=fxList.length-1;i>=0;i--) if (fxList[i].t>fxList[i].life) fxList.splice(i,1);
  }

  // === Hits & stomps ===
  function takeHit(){
    if (player.iFrames>0) return;
    player.iFrames = 1.15;
    player.lives = Math.max(0, player.lives-1);

    if (player.lives===2){
      const oldH=pH(); player.stage=1; player.y += (oldH - pH());
    } else if (player.lives===1){
      const oldH=pH(); player.stage=2; player.y += (oldH - pH());
    } else {
      reset();
    }
    player.vx = -player.face*240;
  }

  function handleInteractions(){
    const pw=pW(), ph=pH();
    for(const o of obstacles){
      if (!aabb(player.x,player.y,pw,ph, o.x,o.y,o.w,o.h)) continue;

      const playerBottom = player.y + ph;
      const overlapTop = playerBottom - o.y;
      const wasFalling = player.vy > 140;
      const isTopHit = wasFalling && overlapTop >= 0 && overlapTop <= 18;

      if (isTopHit){
        spawnBoom(o.x + o.w/2, o.y);
        score += 3;
        removeObstacle(o);
        player.vy = -560;
      } else {
        takeHit();
      }
      break;
    }
  }

  // === Castle & Flag ===
  const castle = { x:(CASTLE_TX+8)*TILE, y:(MAP_H-2)*TILE, w:300, h:260 };
  const pole = { x:(POLE_TX)*TILE + TILE/2, topY:(MAP_H-10)*TILE, bottomY:(MAP_H-2)*TILE };

  function reachedFlag(){
    const fx = pole.x - 10;
    return player.x + pW() > fx && player.x < fx + 22 && player.onGround && player.x > (FLAG_TX*TILE - 40);
  }

  // === Draw helpers ===
  function cloud(x,y,r){
    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.beginPath();
    ctx.arc(x,y,r*0.8,0,Math.PI*2);
    ctx.arc(x+r*0.9,y+6,r*0.65,0,Math.PI*2);
    ctx.arc(x-r*0.9,y+10,r*0.55,0,Math.PI*2);
    ctx.closePath(); ctx.fill();
  }
  function drawBackground(){
    ctx.save();
    ctx.translate(-cam.x*0.25, 0);
    for(let i=0;i<12;i++) cloud(120+i*270, 58+(i%3)*22, 46);
    ctx.restore();

    ctx.save();
    ctx.globalAlpha=0.9;
    ctx.fillStyle="rgba(0,40,90,.35)";
    ctx.fillRect(0, 92, W, 44);
    ctx.fillStyle="rgba(255,255,255,.92)";
    ctx.font="800 22px system-ui";
    ctx.fillText("Ege körfez sahil", 18, 122);
    ctx.restore();

    const zoneX = 100*TILE;
    if (cam.x > zoneX - 400 && cam.x < zoneX + 1200){
      ctx.save();
      ctx.globalAlpha=0.85;
      ctx.fillStyle="rgba(0,0,0,.25)";
      ctx.fillRect(W-360, 146, 340, 40);
      ctx.fillStyle="#fff";
      ctx.font="800 18px system-ui";
      ctx.fillText("Karşıyaka sahil", W-338, 172);
      ctx.restore();
    }
  }

  function drawTiles(){
    const startTx=Math.floor(cam.x/TILE);
    const endTx=Math.ceil((cam.x+W)/TILE);
    for(let ty=0; ty<MAP_H; ty++){
      for(let tx=startTx; tx<=endTx; tx++){
        if (tileAt(tx,ty)!==1) continue;
        const x=tx*TILE - cam.x;
        const y=ty*TILE - cam.y;
        const isGround = (ty >= MAP_H-2);
        ctx.fillStyle = isGround ? "rgba(40,120,60,1)" : "rgba(165,105,60,1)";
        ctx.fillRect(x,y,TILE,TILE);
        ctx.strokeStyle="rgba(0,0,0,.18)";
        ctx.strokeRect(x+0.5,y+0.5,TILE-1,TILE-1);
      }
    }
  }

  function labelAtWorld(wx,wy,text){
    const sx=wx-cam.x, sy=wy-cam.y;
    if (sx<-400 || sx>W+400) return;
    ctx.save();
    ctx.font="800 16px system-ui";
    const tw=ctx.measureText(text).width;
    ctx.globalAlpha=0.92;
    ctx.fillStyle="rgba(0,0,0,.35)";
    ctx.fillRect(sx-6, sy-22, tw+12, 28);
    ctx.fillStyle="#fff";
    ctx.fillText(text, sx, sy-2);
    ctx.restore();
  }
  function drawLandmarks(){
    labelAtWorld(14*TILE,  (MAP_H-4)*TILE,   "Bornova ovası");
    labelAtWorld(34*TILE,  (MAP_H-2-5)*TILE, "Bayraklı üst geçit");
    labelAtWorld(58*TILE,  (MAP_H-2-3)*TILE, "Karşıyaka otoban girişi");
    labelAtWorld(84*TILE,  (MAP_H-2-4)*TILE, "Alaybey girişi");
    labelAtWorld(104*TILE, (MAP_H-2-2)*TILE, "Karşıyaka");
  }

  function drawNameTag(cx, topY, text){
    ctx.save();
    ctx.font="900 14px system-ui";
    const tw=ctx.measureText(text).width;
    ctx.globalAlpha=0.95;
    ctx.fillStyle="rgba(0,0,0,.50)";
    ctx.fillRect(cx - tw/2 - 8, topY - 24, tw + 16, 22);
    ctx.fillStyle="#fff";
    ctx.fillText(text, cx - tw/2, topY - 8);
    ctx.restore();
  }

  // --- Small drawing primitives for friends ---
  function drawFaceBase(x,y,w,h, skin){
    ctx.fillStyle=skin;
    ctx.beginPath();
    ctx.ellipse(x+w*0.5, y+h*0.35, w*0.28, h*0.25, 0, 0, Math.PI*2);
    ctx.fill();
  }
  function drawEyes(x,y,w,h, slanted){
    ctx.save();
    ctx.strokeStyle="rgba(20,20,20,.9)";
    ctx.lineWidth=2.2;
    const ey=y+h*0.34;
    const ex1=x+w*0.43, ex2=x+w*0.57;
    if(!slanted){
      ctx.beginPath(); ctx.moveTo(ex1-6,ey); ctx.lineTo(ex1+6,ey); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ex2-6,ey); ctx.lineTo(ex2+6,ey); ctx.stroke();
    }else{
      ctx.beginPath(); ctx.moveTo(ex1-7,ey+3); ctx.lineTo(ex1+7,ey-3); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ex2-7,ey-3); ctx.lineTo(ex2+7,ey+3); ctx.stroke();
    }
    ctx.restore();
  }
  function drawMustache(x,y,w,h){
    ctx.save();
    ctx.strokeStyle="rgba(20,20,20,.95)";
    ctx.lineWidth=3.5;
    const my=y+h*0.41;
    ctx.beginPath(); ctx.moveTo(x+w*0.46,my); ctx.lineTo(x+w*0.34,my+2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+w*0.54,my); ctx.lineTo(x+w*0.66,my+2); ctx.stroke();
    ctx.restore();
  }
  function drawBody(x,y,w,h,color){
    ctx.fillStyle=color;
    ctx.fillRect(x+w*0.28, y+h*0.46, w*0.44, h*0.44);
    ctx.fillRect(x+w*0.24, y+h*0.62, w*0.18, h*0.32);
    ctx.fillRect(x+w*0.58, y+h*0.62, w*0.18, h*0.32);
  }
  function drawBlondMustacheMan(x,y,w,h){
    ctx.fillStyle="rgba(245,215,60,1)";
    ctx.beginPath(); ctx.ellipse(x+w*0.5,y+h*0.24,w*0.33,h*0.23,0,0,Math.PI*2); ctx.fill();
    drawFaceBase(x,y,w,h,"rgba(255,225,200,1)");
    drawEyes(x,y,w,h,false); drawMustache(x,y,w,h);
    drawBody(x,y,w,h,"rgba(80,120,200,1)");
  }
  function drawHairyMan(x,y,w,h){
    ctx.fillStyle="rgba(40,25,15,1)";
    ctx.beginPath(); ctx.ellipse(x+w*0.5,y+h*0.23,w*0.35,h*0.25,0,0,Math.PI*2); ctx.fill();
    drawFaceBase(x,y,w,h,"rgba(255,220,195,1)");
    drawEyes(x,y,w,h,false);
    drawBody(x,y,w,h,"rgba(60,160,120,1)");
  }
  function drawBaldMustacheMan(x,y,w,h){
    drawFaceBase(x,y,w,h,"rgba(255,225,200,1)");
    drawEyes(x,y,w,h,false); drawMustache(x,y,w,h);
    drawBody(x,y,w,h,"rgba(140,80,170,1)");
  }
  function drawSlantedEyesGirl(x,y,w,h){
    ctx.fillStyle="rgba(25,20,15,1)";
    ctx.beginPath(); ctx.ellipse(x+w*0.5,y+h*0.24,w*0.35,h*0.25,0,0,Math.PI*2); ctx.fill();
    drawFaceBase(x,y,w,h,"rgba(255,225,205,1)");
    drawEyes(x,y,w,h,true);
    drawBody(x,y,w,h,"rgba(230,90,150,1)");
  }
  function drawBlondeGirl(x,y,w,h){
    ctx.fillStyle="rgba(250,220,80,1)";
    ctx.beginPath(); ctx.ellipse(x+w*0.5,y+h*0.24,w*0.36,h*0.25,0,0,Math.PI*2); ctx.fill();
    drawFaceBase(x,y,w,h,"rgba(255,225,200,1)");
    drawEyes(x,y,w,h,false);
    drawBody(x,y,w,h,"rgba(250,120,70,1)");
  }
  function drawTallBlackGirl(x,y,w,h){
    ctx.fillStyle="rgba(10,10,10,1)";
    ctx.beginPath(); ctx.ellipse(x+w*0.5,y+h*0.24,w*0.36,h*0.26,0,0,Math.PI*2); ctx.fill();
    drawFaceBase(x,y,w,h,"rgba(145,95,70,1)");
    drawEyes(x,y,w,h,false);
    ctx.fillStyle="rgba(40,40,80,1)";
    ctx.fillRect(x+w*0.26,y+h*0.46,w*0.48,h*0.56);
    ctx.strokeStyle="rgba(255,255,255,.18)";
    ctx.strokeRect(x+1,y+1,w-2,h-2);
  }
  function drawCar(x,y,w,h){
    ctx.fillStyle="rgba(40,90,180,1)";
    roundRect(x, y+h*0.28, w, h*0.55, 10, true, false);
    ctx.fillStyle="rgba(55,120,210,1)";
    roundRect(x+w*0.18, y, w*0.56, h*0.45, 10, true, false);
    ctx.fillStyle="rgba(170,230,255,.85)";
    roundRect(x+w*0.26, y+h*0.12, w*0.40, h*0.24, 8, true, false);
    ctx.fillStyle="rgba(20,20,20,1)";
    ctx.beginPath(); ctx.arc(x+w*0.25,y+h*0.90,8,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+w*0.75,y+h*0.90,8,0,Math.PI*2); ctx.fill();
  }
  function drawUnoCard(x,y,w,h, spin){
    ctx.save();
    // rotate a little for spin effect
    if (spin){
      ctx.translate(x+w/2, y+h/2);
      ctx.rotate(spin);
      x = -w/2; y = -h/2;
    }
    ctx.fillStyle="rgba(200,30,40,1)";
    roundRect(x,y,w,h,10,true,false);
    ctx.fillStyle="rgba(20,20,20,.25)";
    ctx.beginPath();
    ctx.ellipse(x+w*0.55,y+h*0.52,w*0.35,h*0.25,-0.3,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle="rgba(255,255,255,.95)";
    ctx.font="900 16px system-ui";
    ctx.fillText("UNO", x+10, y+h*0.64);
    ctx.restore();
  }
  function drawGirlWithPiano(x,y,w,h){
    drawBlondeGirl(x,y,w*0.55,h);
    const px=x+w*0.50, py=y+h*0.56;
    ctx.fillStyle="rgba(20,20,25,1)";
    roundRect(px,py,w*0.48,h*0.34,8,true,false);
    ctx.fillStyle="rgba(255,255,255,.9)";
    for(let i=0;i<6;i++) ctx.fillRect(px+6+i*8, py+h*0.22, 4, 10);
  }
  function drawManWithLaptop(x,y,w,h){
    drawHairyMan(x,y,w*0.55,h);
    const lx=x+w*0.52, ly=y+h*0.60;
    ctx.fillStyle="rgba(30,30,35,1)";
    roundRect(lx,ly,w*0.44,h*0.24,7,true,false);
    ctx.fillStyle="rgba(120,200,255,.85)";
    roundRect(lx+4,ly+4,w*0.44-8,h*0.24-10,6,true,false);
  }
  function drawFlower(x,y,w,h){
    const cx=x+w*0.52, cy=y+h*0.48;
    ctx.save(); ctx.translate(cx,cy);
    ctx.fillStyle="rgba(255,200,0,.95)";
    for(let i=0;i<6;i++){
      ctx.rotate(Math.PI/3);
      ctx.beginPath(); ctx.ellipse(0,-h*0.20,w*0.12,h*0.18,0,0,Math.PI*2); ctx.fill();
    }
    ctx.fillStyle="rgba(255,80,80,.95)";
    ctx.beginPath(); ctx.arc(0,0,Math.min(w,h)*0.12,0,Math.PI*2); ctx.fill();
    ctx.restore();
    ctx.fillStyle="rgba(30,130,70,.95)";
    ctx.fillRect(x+w*0.48,y+h*0.40,w*0.06,h*0.60);
  }
  function drawAngel(x,y,w,h){
    ctx.fillStyle="rgba(255,255,255,.92)";
    ctx.beginPath();
    ctx.ellipse(x+w*0.30,y+h*0.50,w*0.22,h*0.20,-0.4,0,Math.PI*2);
    ctx.ellipse(x+w*0.70,y+h*0.50,w*0.22,h*0.20,0.4,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle="rgba(255,230,120,.95)";
    ctx.lineWidth=4;
    ctx.beginPath(); ctx.ellipse(x+w*0.50,y+h*0.18,w*0.18,h*0.10,0,0,Math.PI*2); ctx.stroke();
    ctx.fillStyle="rgba(240,240,255,1)";
    roundRect(x+w*0.35,y+h*0.28,w*0.30,h*0.62,10,true,false);
    ctx.fillStyle="rgba(25,20,15,1)";
    ctx.beginPath(); ctx.ellipse(x+w*0.50,y+h*0.22,w*0.20,h*0.16,0,0,Math.PI*2); ctx.fill();
    drawFaceBase(x,y,w,h,"rgba(255,225,200,1)");
    drawEyes(x,y,w,h,false);
  }
  function drawBeer(x,y,w,h){
    ctx.fillStyle="rgba(255,255,255,.85)";
    roundRect(x+w*0.22,y+h*0.18,w*0.52,h*0.72,10,true,false);
    ctx.fillStyle="rgba(255,190,40,.95)";
    roundRect(x+w*0.24,y+h*0.34,w*0.48,h*0.54,8,true,false);
    ctx.fillStyle="rgba(255,255,255,.95)";
    ctx.beginPath();
    ctx.ellipse(x+w*0.48,y+h*0.30,w*0.22,h*0.12,0,0,Math.PI*2);
    ctx.ellipse(x+w*0.58,y+h*0.30,w*0.18,h*0.10,0,0,Math.PI*2);
    ctx.ellipse(x+w*0.38,y+h*0.30,w*0.18,h*0.10,0,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle="rgba(255,255,255,.85)";
    ctx.lineWidth=6;
    ctx.beginPath();
    ctx.arc(x+w*0.76,y+h*0.52,w*0.12,-Math.PI/2,Math.PI/2);
    ctx.stroke();
  }

  function drawObstacle(o){
    let x = Math.round(o.x - cam.x);
    let y = Math.round(o.y - cam.y);

    ctx.fillStyle="rgba(0,0,0,.16)";
    ctx.beginPath();
    ctx.ellipse(x+o.w/2, y+o.h+10, o.w*0.45, 7, 0, 0, Math.PI*2);
    ctx.fill();

    if (o.kind==="blond_mustache_man") drawBlondMustacheMan(x,y,o.w,o.h);
    else if (o.kind==="hairy_man") drawHairyMan(x,y,o.w,o.h);
    else if (o.kind==="car") drawCar(x,y,o.w,o.h);
    else if (o.kind==="slanted_eyes_girl") drawSlantedEyesGirl(x,y,o.w,o.h);
    else if (o.kind==="bald_mustache_man") drawBaldMustacheMan(x,y,o.w,o.h);
    else if (o.kind==="uno_card") drawUnoCard(x,y,o.w,o.h, o.spin);
    else if (o.kind==="blonde_girl") drawBlondeGirl(x,y,o.w,o.h);
    else if (o.kind==="tall_black_girl") drawTallBlackGirl(x,y,o.w,o.h);
    else if (o.kind==="girl_piano") drawGirlWithPiano(x,y,o.w,o.h);
    else if (o.kind==="man_laptop") drawManWithLaptop(x,y,o.w,o.h);
    else if (o.kind==="flower") drawFlower(x,y,o.w,o.h);
    else if (o.kind==="angel") drawAngel(x,y,o.w,o.h);
    else if (o.kind==="beer"){
      // draw zigzag trail (visible line) for Aşkiyom
      ctx.save();
      ctx.globalAlpha=0.55;
      ctx.strokeStyle="rgba(255,255,255,.9)";
      ctx.lineWidth=2;
      ctx.beginPath();
      const steps=6;
      for(let i=0;i<=steps;i++){
        const px = x + i*(o.w/steps);
        const py = y + o.h*0.45 + Math.sin(o.t*o.zigFreq + i*0.9) * 10;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.restore();
      drawBeer(x,y,o.w,o.h);
    }

    drawNameTag(x+o.w/2, y, o.name);
  }

  function drawObstacles(){ for(const o of obstacles) drawObstacle(o); }

  function drawFX(){
    for(const f of fxList){
      const a = clamp(1 - (f.t / f.life), 0, 1);
      const sx=f.x-cam.x, sy=f.y-cam.y;

      ctx.save();
      ctx.globalAlpha = 0.95*a;
      ctx.fillStyle="rgba(0,0,0,.42)";
      roundRect(sx-62, sy-70, 124, 38, 12, true, false);
      ctx.fillStyle="#fff";
      ctx.font="900 24px system-ui";
      ctx.fillText("BOOM", sx-38, sy-42);
      ctx.restore();

      for(const p of f.sparks){
        const px=sx+p.x, py=sy+p.y;
        const hot=clamp(1 - f.t/f.life, 0, 1);
        ctx.save();
        ctx.globalAlpha=0.85*a;
        ctx.fillStyle=`rgba(255,${Math.floor(150+hot*90)},${Math.floor(30+hot*50)},1)`;
        ctx.beginPath(); ctx.arc(px,py,p.r,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }
  }

  // === Player draw ===
  function drawPlayer(){
    const w=pW(), h=pH();
    const x=Math.round(player.x-cam.x);
    const y=Math.round(player.y-cam.y);
    const blink = player.iFrames>0 ? (Math.floor(performance.now()/80)%2===0) : true;
    if(!blink) return;

    ctx.fillStyle="rgba(0,0,0,.18)";
    ctx.beginPath(); ctx.ellipse(x+w/2, y+h+6, w*0.55, 7, 0, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle="rgba(30,40,55,1)";
    roundRect(x+2, y+Math.max(10, h*0.28), w-4, h*0.72, 10, true, false);

    ctx.fillStyle="rgba(245,245,245,1)";
    roundRect(x+3, y+Math.max(18, h*0.55), w-6, h*0.45, 10, true, false);

    ctx.fillStyle="rgba(255,225,200,1)";
    ctx.beginPath(); ctx.ellipse(x+w/2, y+10, w*0.20, h*0.18, 0, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle="rgba(20,20,20,.95)";
    ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(x+w/2-3, y+12); ctx.lineTo(x+w/2-11, y+13); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+w/2+3, y+12); ctx.lineTo(x+w/2+11, y+13); ctx.stroke();

    ctx.fillStyle="rgba(50,170,90,1)";
    roundRect(x-2, y+1, w+4, h*0.14, 10, true, false);
    ctx.fillStyle="rgba(40,140,75,1)";
    roundRect(x+2, y-6, w-4, h*0.10, 10, true, false);
  }

  function drawHUD(){
    ctx.save();
    ctx.globalAlpha=0.92;
    ctx.fillStyle="rgba(0,0,0,.28)";
    roundRect(18, 18, 290, 56, 12, true, false);
    ctx.fillStyle="#fff";
    ctx.font="900 16px system-ui";
    ctx.fillText("Счёт: " + score, 34, 48);

    for(let i=0;i<3;i++){
      const hx=170 + i*26, hy=44;
      ctx.fillStyle = (i<player.lives) ? "rgba(255,80,90,1)" : "rgba(255,255,255,.25)";
      ctx.beginPath();
      ctx.arc(hx, hy, 7, 0, Math.PI*2);
      ctx.arc(hx+11, hy, 7, 0, Math.PI*2);
      ctx.lineTo(hx+5.5, hy+16);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  // === Castle + Alena ===
  function drawAlena(x,y){
    ctx.save();
    ctx.fillStyle="rgba(250,220,80,1)";
    ctx.beginPath(); ctx.ellipse(x,y-44,22,16,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="rgba(255,225,200,1)";
    ctx.beginPath(); ctx.ellipse(x,y-36,12,12,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="rgba(230,70,90,1)";
    roundRect(x-16,y-24,32,38,10,true,false);
    ctx.restore();
  }
  function drawDialog(text){
    ctx.save();
    ctx.globalAlpha=0.97;
    ctx.fillStyle="rgba(0,0,0,.62)";
    roundRect(40, H-150, W-80, 100, 14, true, false);
    ctx.fillStyle="#fff";
    ctx.font="900 30px system-ui";
    ctx.fillText(text, 70, H-92);
    ctx.font="700 14px system-ui";
    ctx.fillStyle="rgba(255,255,255,.80)";
    ctx.fillText("Игра окончена — нажми R для перезапуска", 70, H-60);
    ctx.restore();
  }

  function drawCastle(){
    const sx=castle.x-cam.x;
    const sy=(MAP_H-2)*TILE - castle.h;

    ctx.fillStyle="rgba(170,150,120,1)";
    roundRect(sx,sy,castle.w,castle.h,16,true,false);

    ctx.fillStyle="rgba(0,0,0,.45)";
    roundRect(sx+castle.w*0.18, sy+12, castle.w*0.64, 38, 10, true, false);
    ctx.fillStyle="#fff";
    ctx.font="900 22px system-ui";
    ctx.fillText("Дом Алёны", sx+castle.w*0.28, sy+39);

    // pole + flag
    const px=pole.x-cam.x;
    ctx.strokeStyle="rgba(40,40,40,.9)";
    ctx.lineWidth=6;
    ctx.beginPath();
    ctx.moveTo(px, pole.topY - cam.y);
    ctx.lineTo(px, pole.bottomY - cam.y);
    ctx.stroke();

    ctx.fillStyle="rgba(240,60,60,.95)";
    ctx.beginPath();
    ctx.moveTo(px, pole.topY - cam.y + 18);
    ctx.lineTo(px+46, pole.topY - cam.y + 30);
    ctx.lineTo(px, pole.topY - cam.y + 42);
    ctx.closePath();
    ctx.fill();

    if (cutscene || gameOver){
      drawAlena(sx+castle.w*0.80, sy+castle.h*0.80);
      drawDialog("WELCOME KOXANIE ❤");
    }
  }

  function drawLandmarkText(){
    labelAtWorld(14*TILE,  (MAP_H-4)*TILE,   "Bornova ovası");
    labelAtWorld(34*TILE,  (MAP_H-2-5)*TILE, "Bayraklı üst geçit");
    labelAtWorld(58*TILE,  (MAP_H-2-3)*TILE, "Karşıyaka otoban girişi");
    labelAtWorld(84*TILE,  (MAP_H-2-4)*TILE, "Alaybey girişi");
    labelAtWorld(104*TILE, (MAP_H-2-2)*TILE, "Karşıyaka");
  }

  // === Main update/draw ===
  function update(dt){
    if (gameOver) return;

    if (player.iFrames>0) player.iFrames = Math.max(0, player.iFrames-dt);

    // cutscene
    if (cutscene){
      player.vx = 140;
      player.vy += GRAV*dt;
      collideAndSlide(dt);

      if (player.x > castle.x - 70){
        player.vx = 0;
        gameOver = true;
      }

      cam.x = clamp(player.x + pW()/2 - W*0.40, 0, worldPxW - W);
      cam.y = 0;

      updateFX(dt);
      document.getElementById("info").textContent = `ФИНАЛ | Счёт:${score} | Жизни:${player.lives}`;
      return;
    }

    // time + spawns
    timeSinceStart += dt;
    updateSpawns(dt);
    updateObstacles(dt);

    // controls
    let ax=0;
    if (keys.has("ArrowLeft")) ax -= MOVE_ACC;
    if (keys.has("ArrowRight")) ax += MOVE_ACC;
    if (ax!==0) player.face = Math.sign(ax);

    player.vx += ax*dt;
    player.vx = clamp(player.vx, -MAX_VX, MAX_VX);

    const jump = keys.has("ArrowUp") || keys.has("Space");
    if (jump && player.onGround){
      player.vy = -pJump();
      player.onGround=false;
    }

    player.vy += GRAV*dt;

    if (player.onGround && ax===0){
      player.vx *= FRICTION;
      if (Math.abs(player.vx)<10) player.vx=0;
    } else if (!player.onGround){
      player.vx *= AIR_DRAG;
    }

    collideAndSlide(dt);

    cam.x = clamp(player.x + pW()/2 - W*0.40, 0, worldPxW - W);
    cam.y = 0;

    // UNO spin update (after movement)
    for(const o of obstacles) if (o.kind==="uno_card") o.spin += dt*6.5;

    handleInteractions();
    updateFX(dt);

    if (reachedFlag()){
      cutscene = true;
      player.x = pole.x - 18;
      player.vx = 140;
    }

    document.getElementById("info").textContent =
      `Счёт:${score} | ${stages[player.stage].name} | Жизни:${player.lives} | Друзья:${obstacles.length}`;
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    drawBackground();
    drawTiles();
    drawLandmarks();
    drawObstacles();
    drawFX();
    drawCastle();
    drawPlayer();
    drawHUD();
  }

  // === Reset ===
  function reset(){
    if (!started) return;
    player.x=70; player.y=0; player.vx=0; player.vy=0;
    player.stage=0; player.lives=3; player.iFrames=0;
    cam.x=0; cam.y=0;

    obstacles.length=0;
    fxList.length=0;
    score=0;

    gameOver=false; cutscene=false;

    timeSinceStart=0;
    spawnIndex=0;
    spawnTimer=0;
    lastSpawnByName.clear();
    activeNames.clear();
  }

  // === Loop ===
  let last=performance.now();
  function loop(now){
    const dt=Math.min(0.033,(now-last)/1000);
    last=now;
    if (started){ update(dt); draw(); }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // === Start button ===
  goBtn.addEventListener("click", ()=>{
    startScreen.classList.add("hidden");
    hud.classList.remove("hidden");
    canvas.style.display="block";
    started=true;
    reset();
  });

})();
</script>
</body>
</html>
