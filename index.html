<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Super Hiko</title>
  <style>
    :root{
      --bg1:#0a1030; --bg2:#070b14;
      --panel: rgba(18,26,58,.88);
      --line: rgba(255,255,255,.14);
      --txt:#eaf0ff;
      --muted: rgba(255,255,255,.82);
      --shadow: 0 16px 45px rgba(0,0,0,.55);
    }
    html,body{height:100%;margin:0;font-family:system-ui,Arial;background:radial-gradient(1200px 700px at 50% 0%, var(--bg1), var(--bg2)); color:var(--txt); overflow:hidden;}
    /* MENU */
    #menu{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;padding:16px;box-sizing:border-box;}
    .panel{
      width:min(900px, 94vw);
      border:1px solid var(--line);
      border-radius:18px;
      background:linear-gradient(180deg, rgba(24,36,72,.92), rgba(10,14,30,.92));
      box-shadow:var(--shadow);
      padding:16px; position:relative; overflow:hidden;
    }
    .panel:before{
      content:""; position:absolute; inset:-60px;
      background:
        radial-gradient(260px 260px at 18% 18%, rgba(80,180,120,.18), transparent 62%),
        radial-gradient(320px 320px at 80% 24%, rgba(70,120,220,.20), transparent 65%),
        radial-gradient(320px 320px at 50% 112%, rgba(220,80,170,.14), transparent 65%);
      pointer-events:none;
    }
    .enemies{
      position:relative;
      margin:0 0 10px;
      padding:10px 12px;
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      background:rgba(255,255,255,.04);
      font-size:12px;
      line-height:1.35;
      color:var(--muted);
      display:flex; flex-wrap:wrap; gap:8px 10px;
    }
    .tag{
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      font-weight:800;
      letter-spacing:.2px;
      user-select:none;
    }
    .startText{
      position:relative;
      margin:8px 0 0;
      padding:16px 14px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.18);
      background:linear-gradient(135deg, rgba(80,180,120,.25), rgba(70,120,220,.22));
      text-align:center;
      font-weight:1000;
      font-size:24px;
      letter-spacing:.6px;
      cursor:pointer;
      user-select:none;
      box-shadow:0 14px 30px rgba(0,0,0,.35);
    }
    .startHint{
      position:relative;
      margin:8px 0 0;
      font-size:12px;
      opacity:.75;
      text-align:center;
    }

    /* GAME LAYOUT (comfortable, not fullscreen) */
    #gameWrap{
      position:fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      padding:12px; box-sizing:border-box;
    }
    .gameShell{
      width:min(980px, 100%);
      height:100%;
      max-height: 920px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    /* Canvas area */
    .screen{
      position:relative;
      flex: 1;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      overflow:hidden;
      box-shadow:var(--shadow);
      background:#000;
    }
    canvas{
      position:absolute; inset:0;
      width:100%; height:100%;
      image-rendering:pixelated;
    }
    .hud{
      position:absolute; left:10px; right:10px; top:10px;
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; z-index:5;
      pointer-events:none;
    }
    .hud .left, .hud .right{display:flex;gap:10px;align-items:center;pointer-events:auto}
    .btn{
      background:rgba(15,24,52,.92); color:#eaf0ff;
      border:1px solid rgba(255,255,255,.15);
      padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:1000;
    }
    .scoreBox{
      background:rgba(0,0,0,.30);
      border:1px solid rgba(255,255,255,.12);
      padding:10px 12px;border-radius:12px;font-weight:1000;
      box-shadow:0 10px 18px rgba(0,0,0,.18);
    }

    /* Overlay end */
    #overlay{
      position:absolute; inset:0;
      display:none; align-items:flex-end; justify-content:center;
      padding:18px; z-index:6; pointer-events:none;
    }
    #overlay .box{
      width:min(760px,92vw);
      background:rgba(0,0,0,.62);
      border:1px solid rgba(255,255,255,.16);
      border-radius:16px;
      padding:16px 16px 14px;
      box-shadow:0 18px 50px rgba(0,0,0,.45);
      backdrop-filter: blur(6px);
    }
    #overlay h2{margin:0;font-size:32px;font-weight:1000}
    #overlay p{margin:6px 0 0;font-size:18px;font-weight:900;opacity:.92}

    /* Nintendo Controller */
    .controller{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      padding:12px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(180deg, rgba(18,26,58,.72), rgba(0,0,0,.20));
      box-shadow:0 12px 26px rgba(0,0,0,.35);
      user-select:none; -webkit-user-select:none;
      touch-action: none;
    }
    .pad{
      width:180px; height:120px;
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 1fr 1fr 1fr;
      gap:8px;
      align-items:center;
      justify-items:center;
    }
    .dkey{
      width:54px; height:54px; border-radius:16px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.25);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.06), 0 10px 18px rgba(0,0,0,.25);
      display:grid; place-items:center;
      font-weight:1000;
      opacity:.95;
    }
    .dkey:active, .akey:active { transform: translateY(1px); }
    .dkey.on, .akey.on{ outline: 3px solid rgba(80,180,120,.55); }

    .centerBrand{
      flex:1;
      text-align:center;
      font-weight:1000;
      opacity:.9;
      letter-spacing:.3px;
      line-height:1.2;
    }
    .centerBrand small{display:block;opacity:.75;font-weight:900;margin-top:4px}

    .buttons{
      width:220px;
      display:flex;
      justify-content:flex-end;
      gap:12px;
      align-items:center;
    }
    .akey{
      width:84px; height:84px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:linear-gradient(135deg, rgba(255,90,120,.35), rgba(255,190,60,.22));
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.06), 0 12px 22px rgba(0,0,0,.28);
      display:grid; place-items:center;
      font-weight:1000; font-size:18px;
    }
    .smallBtn{
      width:74px; height:44px; border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.22);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.05), 0 10px 18px rgba(0,0,0,.22);
      display:grid; place-items:center;
      font-weight:1000; font-size:12px;
      opacity:.92;
    }

    @media (max-width:560px){
      .startText{font-size:20px}
      .controller{padding:10px}
      .pad{width:150px;height:110px}
      .dkey{width:48px;height:48px}
      .buttons{width:180px}
      .akey{width:74px;height:74px}
    }
  </style>
</head>
<body>

  <div id="menu">
    <div class="panel">
      <div class="enemies" id="enemyTags"></div>

      <div class="startText" id="startText">
        ОТВЕДИ ХИКМЕТА К ДОМУ АЛЁНЫ
      </div>
      <div class="startHint">Нажми на текст выше, чтобы начать</div>
    </div>
  </div>

  <div id="gameWrap">
    <div class="gameShell">
      <div class="screen">
        <canvas id="c"></canvas>

        <div class="hud">
          <div class="left">
            <button class="btn" id="back">⬅</button>
            <button class="btn" id="restart">⟲</button>
          </div>
          <div class="right">
            <div class="scoreBox" id="hudText">Счёт: 0 • ❤❤❤</div>
          </div>
        </div>

        <div id="overlay">
          <div class="box">
            <h2>WELCOME KOXANIE ❤</h2>
            <p id="finalScore">Счёт: 0</p>
          </div>
        </div>
      </div>

      <!-- Nintendo controller -->
      <div class="controller" id="controller">
        <div class="pad">
          <div></div>
          <div class="dkey" id="up">▲</div>
          <div></div>
          <div class="dkey" id="left">◀</div>
          <div class="dkey" id="mid">●</div>
          <div class="dkey" id="right">▶</div>
          <div></div>
          <div class="dkey" id="down">▼</div>
          <div></div>
        </div>

        <div class="centerBrand">
          SUPER HIKO
          <small>Jump + направления (как Nintendo)</small>
        </div>

        <div class="buttons">
          <div class="smallBtn" id="brakeBtn">BRAKE</div>
          <div class="akey" id="jumpBtn">JUMP</div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ----- Friends -----
  const friends = [
    {name:"Zloy Stas", kind:"blond_mustache_man", lane:"air",   speed:360, motion:"dash"},
    {name:"Arkadağ", kind:"hairy_man",           lane:"ground",speed:300, motion:"steady"},
    {name:"Timur Niva", kind:"car",              lane:"ground",speed:420, motion:"bump"},
    {name:"Mona", kind:"slanted_girl",           lane:"mid",   speed:350, motion:"wobble"},
    {name:"Emil Abi", kind:"bald_mustache_man",  lane:"ground",speed:340, motion:"steady"},
    {name:"Uno", kind:"uno_card",                lane:"mid",   speed:380, motion:"spin"},
    {name:"Asya", kind:"blonde_girl",            lane:"ground",speed:310, motion:"steady"},
    {name:"Aynura", kind:"tall_black_girl",      lane:"air",   speed:360, motion:"dive"},
    {name:"Zamina", kind:"girl_piano",           lane:"ground",speed:290, motion:"heavy"},
    {name:"Elnur", kind:"man_laptop",            lane:"air",   speed:350, motion:"drift"},
    {name:"Angelina Minsk", kind:"flower",       lane:"air",   speed:270, motion:"float"},
    {name:"Malika", kind:"angel",                lane:"air",   speed:260, motion:"float"},
    {name:"Aşkiyom", kind:"beer",                lane:"mid",   speed:320, motion:"zigzag"},
  ];

  // Menu tags (small names only)
  const enemyTags = document.getElementById("enemyTags");
  friends.forEach(e=>{
    const t=document.createElement("div");
    t.className="tag";
    t.textContent=e.name;
    enemyTags.appendChild(t);
  });

  // ----- DOM -----
  const menu = document.getElementById("menu");
  const startText = document.getElementById("startText");
  const gameWrap = document.getElementById("gameWrap");
  const backBtn = document.getElementById("back");
  const restartBtn = document.getElementById("restart");
  const hudText = document.getElementById("hudText");
  const overlay = document.getElementById("overlay");
  const finalScore = document.getElementById("finalScore");

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // Controller buttons
  const leftKey = document.getElementById("left");
  const rightKey = document.getElementById("right");
  const upKey = document.getElementById("up");
  const downKey = document.getElementById("down");
  const jumpBtn = document.getElementById("jumpBtn");
  const brakeBtn = document.getElementById("brakeBtn");

  // ----- Sizing (comfortable phone) -----
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled = false;
  }
  window.addEventListener("resize", resizeCanvas);

  // ----- World -----
  const TILE=32;
  const MAP_W=210, MAP_H=18;
  const WORLD_W=MAP_W*TILE, WORLD_H=MAP_H*TILE;

  const GRAV=1850;

  const map = Array.from({length:MAP_H},()=>Array(MAP_W).fill(0));
  for(let x=0;x<MAP_W;x++){ map[MAP_H-1][x]=1; map[MAP_H-2][x]=1; }
  function putRect(tx,ty,tw,th){
    for(let y=ty;y<ty+th;y++)for(let x=tx;x<tx+tw;x++){
      if(y>=0&&y<MAP_H&&x>=0&&x<MAP_W) map[y][x]=1;
    }
  }
  const tileAt=(tx,ty)=> (tx<0||ty<0||tx>=MAP_W||ty>=MAP_H)?0:map[ty][tx];

  // Platforms & final
  putRect(14, MAP_H-4, 10, 2);        // Bornova ovası
  putRect(34, MAP_H-2-5, 10, 5);      // Bayraklı üst geçit
  putRect(58, MAP_H-2-3, 12, 3);      // Karşıyaka otoban girişi
  putRect(84, MAP_H-2-4, 12, 4);      // Alaybey girişi
  putRect(104, MAP_H-2-2, 14, 2);     // Karşıyaka

  const LAST_RISE_TX=132;
  putRect(LAST_RISE_TX, MAP_H-2-3, 10, 3);

  const SAFE_WALK_TX=LAST_RISE_TX+10;
  putRect(SAFE_WALK_TX, MAP_H-2-2, 6, 2);

  const CASTLE_TX=SAFE_WALK_TX+6;
  putRect(CASTLE_TX, MAP_H-6, 20, 1);

  const FLAG_LINE_X=(SAFE_WALK_TX*TILE)-8;
  const STOP_OBS_X=(LAST_RISE_TX*TILE)-40;

  const castle={ x:(CASTLE_TX+8)*TILE, y:(MAP_H-2)*TILE, w:320, h:290 };
  const pole={ x:(CASTLE_TX+17)*TILE + TILE/2, topY:(MAP_H-10)*TILE, bottomY:(MAP_H-2)*TILE };

  // ----- Player -----
  const stages=[
    {name:"Super Hiko", w:76, h:108, jump:1180},
    {name:"Midi Hiko",  w:60, h:84,  jump:1120},
    {name:"Mini Hiko",  w:52, h:68,  jump:1080},
  ];
  const player={ x:70, y:0, vx:0, vy:0, onGround:false, stage:0, lives:3, iFrames:0 };
  const pW=()=>stages[player.stage].w;
  const pH=()=>stages[player.stage].h;
  const pJump=()=>stages[player.stage].jump;

  // ----- Camera -----
  const cam={ x:0, y:0 };

  // ----- Utils -----
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const aabb=(ax,ay,aw,ah,bx,by,bw,bh)=> ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;

  function solidTiles(x,y,w,h){
    const left=Math.floor(x/TILE), right=Math.floor((x+w)/TILE);
    const top=Math.floor(y/TILE), bottom=Math.floor((y+h)/TILE);
    const out=[];
    for(let ty=top;ty<=bottom;ty++)for(let tx=left;tx<=right;tx++){
      if(tileAt(tx,ty)===1) out.push({tx,ty});
    }
    return out;
  }

  function collide(dt){
    const w=pW(), h=pH();
    player.onGround=false;

    player.x += player.vx*dt;
    for(const t of solidTiles(player.x,player.y,w,h)){
      const rx=t.tx*TILE, ry=t.ty*TILE;
      if(aabb(player.x,player.y,w,h, rx,ry,TILE,TILE)){
        if(player.vx>0) player.x = rx-w;
        else if(player.vx<0) player.x = rx+TILE;
        player.vx=0;
      }
    }

    player.y += player.vy*dt;
    for(const t of solidTiles(player.x,player.y,w,h)){
      const rx=t.tx*TILE, ry=t.ty*TILE;
      if(aabb(player.x,player.y,w,h, rx,ry,TILE,TILE)){
        if(player.vy>0){
          player.y = ry-h;
          player.vy=0;
          player.onGround=true;
        }else if(player.vy<0){
          player.y = ry+TILE;
          player.vy=0;
        }
      }
    }

    player.x = clamp(player.x, 0, WORLD_W - w);
    if(player.y > WORLD_H + 200) resetGame();
  }

  // ----- Controller state -----
  const input = {
    left:false, right:false, up:false, down:false,
    jumpPressed:false,
    brake:false
  };

  function setBtnState(el, on){
    el.classList.toggle("on", !!on);
  }

  // Pointer handlers for keys
  function bindHold(el, onDown, onUp){
    const down = (e)=>{ e.preventDefault(); onDown(); };
    const up   = (e)=>{ e.preventDefault(); onUp(); };
    el.addEventListener("pointerdown", down, {passive:false});
    el.addEventListener("pointerup", up, {passive:false});
    el.addEventListener("pointercancel", up, {passive:false});
    el.addEventListener("pointerleave", up, {passive:false});
  }

  bindHold(leftKey,  ()=>{input.left=true;  setBtnState(leftKey,true);},  ()=>{input.left=false;  setBtnState(leftKey,false);} );
  bindHold(rightKey, ()=>{input.right=true; setBtnState(rightKey,true);}, ()=>{input.right=false; setBtnState(rightKey,false);} );
  bindHold(upKey,    ()=>{input.up=true;    setBtnState(upKey,true);},    ()=>{input.up=false;    setBtnState(upKey,false);} );
  bindHold(downKey,  ()=>{input.down=true;  setBtnState(downKey,true);},  ()=>{input.down=false;  setBtnState(downKey,false);} );

  // Jump: press
  bindHold(jumpBtn,
    ()=>{ input.jumpPressed=true; setBtnState(jumpBtn,true); },
    ()=>{ input.jumpPressed=false; setBtnState(jumpBtn,false); }
  );

  // Brake
  bindHold(brakeBtn,
    ()=>{ input.brake=true; setBtnState(brakeBtn,true); },
    ()=>{ input.brake=false; setBtnState(brakeBtn,false); }
  );

  // Also allow tap on canvas to jump (optional comfort)
  canvas.addEventListener("pointerdown", (e)=>{
    if(!running) return;
    input.jumpPressed=true;
    setBtnState(jumpBtn,true);
    setTimeout(()=>{ input.jumpPressed=false; setBtnState(jumpBtn,false); }, 90);
  }, {passive:true});

  // Prevent page scroll while holding controller
  document.getElementById("controller").addEventListener("touchmove", (e)=>e.preventDefault(), {passive:false});

  // ----- Movement model -----
  function applyMovement(dt){
    // left/right control like classic
    const accel = 1400;
    const maxSpeed = input.brake ? 220 : 520;
    const friction = player.onGround ? 0.82 : 0.94;

    if(input.left)  player.vx -= accel*dt;
    if(input.right) player.vx += accel*dt;

    // cap
    player.vx = clamp(player.vx, -maxSpeed, maxSpeed);

    // friction when no key
    if(!input.left && !input.right){
      player.vx *= Math.pow(friction, dt*60);
      if(Math.abs(player.vx)<8) player.vx=0;
    }

    // jump
    if(input.jumpPressed && player.onGround){
      player.vy = -pJump();
      player.onGround=false;
    }
  }

  // ----- Obstacles -----
  const obstacles=[];
  const activeNames=new Set();
  const lastSpawn=new Map();
  let spawnIndex=0;
  let spawnTimer=0;

  function obsSize(kind){
    if(kind==="car") return {w:160,h:100};
    if(kind==="tall_black_girl") return {w:110,h:170};
    if(kind==="uno_card") return {w:120,h:160};
    if(kind==="beer") return {w:120,h:170};
    if(kind==="girl_piano") return {w:170,h:120};
    if(kind==="man_laptop") return {w:160,h:120};
    if(kind==="angel") return {w:150,h:150};
    return {w:140,h:140};
  }
  function laneY(lane,h){
    const groundY=(MAP_H-2)*TILE;
    if(lane==="ground") return groundY - h;
    if(lane==="mid") return groundY - h - (120 + Math.random()*60);
    return groundY - h - (210 + Math.random()*110);
  }
  function canSpawn(name, time){
    if(activeNames.has(name)) return false;
    const last=lastSpawn.get(name) ?? -9999;
    return (time-last) >= 2;
  }
  function spawnOne(time){
    for(let tries=0;tries<friends.length;tries++){
      const f = friends[spawnIndex % friends.length];
      spawnIndex++;
      if(!canSpawn(f.name,time)) continue;

      const sz=obsSize(f.kind);
      const baseY=laneY(f.lane, sz.h);

      // random spawn origin (different places)
      const origin = Math.random();
      let startX = cam.x + canvas.clientWidth + 260 + Math.random()*160;
      let y = baseY;

      if(origin < 0.33){ y = baseY; }
      else if(origin < 0.66){ y = baseY - (80 + Math.random()*90); }
      else { y = baseY - (150 + Math.random()*140); }

      const o={
        name:f.name, kind:f.kind, motion:f.motion,
        x:startX, baseY, y,
        w:sz.w, h:sz.h,
        vx:-f.speed, vy:0,
        t:0, spin:0,
        zigAmp:70+Math.random()*35,
        zigFreq:2.2+Math.random()*1.2,
        landed:false
      };
      if(o.motion==="dive"){ o.y = 30 + Math.random()*140; o.vy=0; o.landed=false; }
      if(o.motion==="float"){ o.y = baseY - (120 + Math.random()*140); }

      obstacles.push(o);
      activeNames.add(o.name);
      lastSpawn.set(o.name,time);
      return;
    }
  }
  function spawnWave(time){
    // always one, sometimes group (2-3)
    spawnOne(time);
    if(Math.random()<0.55) spawnOne(time+0.01);
    if(Math.random()<0.25) spawnOne(time+0.02);
  }
  function updateObstacles(dt){
    for(const o of obstacles){
      o.t += dt;
      o.x += o.vx*dt;

      if(o.motion==="zigzag"){
        o.y = o.baseY + Math.sin(o.t*o.zigFreq)*o.zigAmp;
      } else if(o.motion==="float"){
        o.y = o.baseY + Math.sin(o.t*3.0)*34;
        const pulse = 0.80 + 0.20*Math.sin(o.t*1.2);
        o.x += (o.vx*(pulse-1))*dt;
      } else if(o.motion==="dive"){
        o.vy += 1450*dt;
        o.y += o.vy*dt;
        if(!o.landed && o.y >= o.baseY){
          o.y=o.baseY; o.vy=0; o.landed=true;
        }
        if(o.landed) o.y = o.baseY + Math.sin(o.t*2.3)*14;
      } else if(o.motion==="drift"){
        o.y = o.baseY + Math.sin(o.t*2.0)*26;
        o.x += Math.sin(o.t*1.5)*22*dt;
      } else if(o.motion==="wobble"){
        o.y = o.baseY + Math.sin(o.t*2.8)*22;
      } else if(o.motion==="spin"){
        o.spin += dt*6.2;
        o.y = o.baseY + Math.sin(o.t*2.3)*20;
      } else if(o.motion==="bump"){
        o.y = o.baseY + Math.abs(Math.sin(o.t*3.2)) * -14;
      } else if(o.motion==="heavy"){
        const stop = (Math.sin(o.t*1.1)>0.86) ? 0.15 : 1.0;
        o.x += o.vx*dt*(stop-1);
        o.y = o.baseY;
      } else if(o.motion==="dash"){
        const dash = 0.80 + 0.45*Math.max(0, Math.sin(o.t*2.1));
        o.x += o.vx*dt*(dash-1);
        o.y = o.baseY + Math.sin(o.t*2.9)*16;
      }
    }

    // cleanup
    for(let i=obstacles.length-1;i>=0;i--){
      if(obstacles[i].x < cam.x - 600){
        const name=obstacles[i].name;
        obstacles.splice(i,1);
        activeNames.delete(name);
      }
    }
  }

  // ----- FX BOOM -----
  const fx=[];
  function boom(x,y){
    const f={x,y,t:0,life:0.6,sparks:[]};
    for(let i=0;i<26;i++){
      f.sparks.push({x:0,y:0,vx:(Math.random()*2-1)*(220+Math.random()*240),vy:-(220+Math.random()*340),r:3+Math.random()*4});
    }
    fx.push(f);
  }
  function updateFX(dt){
    for(const f of fx){
      f.t+=dt;
      for(const p of f.sparks){
        p.vy += 980*dt;
        p.x += p.vx*dt;
        p.y += p.vy*dt;
        p.vx *= Math.pow(0.96, dt*60);
      }
    }
    for(let i=fx.length-1;i>=0;i--) if(fx[i].t>fx[i].life) fx.splice(i,1);
  }

  // ----- Game state -----
  let running=false;
  let score=0;
  let flagTriggered=false;
  let cutscene=false;
  let gameOver=false;
  let time=0;

  function hearts(){
    return "❤".repeat(player.lives) + "♡".repeat(3-player.lives);
  }

  function takeHit(){
    if(player.iFrames>0) return;
    player.iFrames=1.1;
    player.lives=Math.max(0, player.lives-1);

    if(player.lives===2){
      const old=pH(); player.stage=1; player.y += (old-pH());
    }else if(player.lives===1){
      const old=pH(); player.stage=2; player.y += (old-pH());
    }else{
      resetGame();
      return;
    }
    player.vx = -260;
  }

  function handleHits(){
    if(flagTriggered) return;

    const pw=pW(), ph=pH();
    for(const o of obstacles){
      if(!aabb(player.x,player.y,pw,ph, o.x,o.y,o.w,o.h)) continue;

      const bottom = player.y + ph;
      const overlapTop = bottom - o.y;
      const topHit = player.vy > 140 && overlapTop >= 0 && overlapTop <= 34;

      if(topHit){
        boom(o.x+o.w/2, o.y);
        score += 3;
        const idx=obstacles.indexOf(o);
        if(idx>=0) obstacles.splice(idx,1);
        activeNames.delete(o.name);
        player.vy = -650;
      }else{
        takeHit();
      }
      break;
    }
  }

  // ----- Drawing -----
  function roundRect(x,y,w,h,r){
    const rr=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function drawBackground(vw,vh){
    // sky->sea->ground
    const g = ctx.createLinearGradient(0,0,0,vh);
    g.addColorStop(0, "#6bb6ff");
    g.addColorStop(0.50, "#bfe6ff");
    g.addColorStop(0.505, "#7bdc6f");
    g.addColorStop(1, "#49b85a");
    ctx.fillStyle=g;
    ctx.fillRect(0,0,vw,vh);

    ctx.globalAlpha=0.88;
    ctx.fillStyle="rgba(0,40,90,.35)";
    ctx.fillRect(0,92,vw,44);
    ctx.fillStyle="rgba(255,255,255,.92)";
    ctx.font="1000 22px system-ui";
    ctx.fillText("Ege körfez sahil", 18, 122);
    ctx.globalAlpha=1;
  }

  function drawTiles(vw,vh){
    const startTx=Math.floor(cam.x/TILE);
    const endTx=Math.ceil((cam.x+vw)/TILE);
    for(let ty=0;ty<MAP_H;ty++){
      for(let tx=startTx;tx<=endTx;tx++){
        if(tileAt(tx,ty)!==1) continue;
        const x=tx*TILE - cam.x;
        const y=ty*TILE - cam.y;
        const ground = (ty>=MAP_H-2);
        ctx.fillStyle = ground ? "rgba(40,120,60,1)" : "rgba(165,105,60,1)";
        ctx.fillRect(x,y,TILE,TILE);
        ctx.strokeStyle="rgba(0,0,0,.18)";
        ctx.strokeRect(x+0.5,y+0.5,TILE-1,TILE-1);
      }
    }
  }

  function label(wx,wy,text){
    const sx=wx-cam.x, sy=wy-cam.y;
    ctx.font="1000 16px system-ui";
    const tw=ctx.measureText(text).width;
    ctx.globalAlpha=0.92;
    ctx.fillStyle="rgba(0,0,0,.35)";
    ctx.fillRect(sx-6, sy-22, tw+12, 28);
    ctx.fillStyle="#fff";
    ctx.fillText(text, sx, sy-2);
    ctx.globalAlpha=1;
  }

  function drawLandmarks(){
    label(14*TILE,  (MAP_H-4)*TILE,   "Bornova ovası");
    label(34*TILE,  (MAP_H-2-5)*TILE, "Bayraklı üst geçit");
    label(58*TILE,  (MAP_H-2-3)*TILE, "Karşıyaka otoban girişi");
    label(84*TILE,  (MAP_H-2-4)*TILE, "Alaybey girişi");
    label(104*TILE, (MAP_H-2-2)*TILE, "Karşıyaka");
  }

  function drawFlagLine(vw,vh){
    const x = FLAG_LINE_X - cam.x;
    ctx.save();
    ctx.globalAlpha=0.88;
    ctx.strokeStyle="rgba(255,255,255,.95)";
    ctx.lineWidth=4;
    ctx.setLineDash([12,12]);
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,vh); ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  function drawNameBig(cx, topY, text){
    ctx.save();
    ctx.font="1000 22px system-ui";
    const tw=ctx.measureText(text).width;
    ctx.globalAlpha=0.98;
    ctx.fillStyle="rgba(0,0,0,.55)";
    ctx.fillRect(cx - tw/2 - 12, topY - 36, tw + 24, 30);
    ctx.fillStyle="#fff";
    ctx.fillText(text, cx - tw/2, topY - 14);
    ctx.restore();
  }

  function drawPerson(x,y,w,h, hair, body, skin, mustache=false, slanted=false){
    ctx.fillStyle=hair;
    ctx.beginPath(); ctx.ellipse(x+w*0.5,y+h*0.20,w*0.36,h*0.26,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle=skin;
    ctx.beginPath(); ctx.ellipse(x+w*0.5,y+h*0.32,w*0.24,h*0.20,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle="rgba(20,20,20,.9)"; ctx.lineWidth=3;
    const ey=y+h*0.32;
    if(!slanted){
      ctx.beginPath(); ctx.moveTo(x+w*0.40,ey); ctx.lineTo(x+w*0.46,ey); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x+w*0.54,ey); ctx.lineTo(x+w*0.60,ey); ctx.stroke();
    }else{
      ctx.beginPath(); ctx.moveTo(x+w*0.39,ey+4); ctx.lineTo(x+w*0.48,ey-4); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x+w*0.52,ey-4); ctx.lineTo(x+w*0.61,ey+4); ctx.stroke();
    }
    if(mustache){
      ctx.beginPath(); ctx.moveTo(x+w*0.44,y+h*0.40); ctx.lineTo(x+w*0.33,y+h*0.42); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x+w*0.56,y+h*0.40); ctx.lineTo(x+w*0.67,y+h*0.42); ctx.stroke();
    }
    ctx.fillStyle=body;
    roundRect(x+w*0.28,y+h*0.46,w*0.44,h*0.50,18); ctx.fill();
  }

  function drawObstacle(o){
    const x=o.x-cam.x, y=o.y-cam.y;
    ctx.fillStyle="rgba(0,0,0,.16)";
    ctx.beginPath(); ctx.ellipse(x+o.w/2, y+o.h+14, o.w*0.45, 9, 0, 0, Math.PI*2); ctx.fill();

    if(o.kind==="car"){
      ctx.fillStyle="rgba(40,90,180,1)";
      roundRect(x, y+o.h*0.25, o.w, o.h*0.55, 18); ctx.fill();
      ctx.fillStyle="rgba(55,120,210,1)";
      roundRect(x+o.w*0.15, y, o.w*0.55, o.h*0.42, 18); ctx.fill();
      ctx.fillStyle="rgba(170,230,255,.85)";
      roundRect(x+o.w*0.25, y+o.h*0.12, o.w*0.38, o.h*0.20, 14); ctx.fill();
      ctx.fillStyle="rgba(20,20,20,1)";
      ctx.beginPath(); ctx.arc(x+o.w*0.24,y+o.h*0.90,12,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(x+o.w*0.76,y+o.h*0.90,12,0,Math.PI*2); ctx.fill();
    } else if(o.kind==="uno_card"){
      ctx.save();
      ctx.translate(x+o.w/2, y+o.h/2);
      ctx.rotate(o.spin);
      ctx.translate(-o.w/2, -o.h/2);
      ctx.fillStyle="rgba(200,30,40,1)";
      roundRect(0,0,o.w,o.h,18); ctx.fill();
      ctx.fillStyle="rgba(255,255,255,.95)";
      ctx.font="1000 28px system-ui";
      ctx.fillText("UNO", 16, o.h*0.66);
      ctx.restore();
    } else if(o.kind==="beer"){
      ctx.save();
      ctx.globalAlpha=0.55;
      ctx.strokeStyle="rgba(255,255,255,.9)";
      ctx.lineWidth=3;
      ctx.beginPath();
      const steps=8;
      for(let i=0;i<=steps;i++){
        const px = x + i*(o.w/steps);
        const py = y + o.h*0.48 + Math.sin(o.t*o.zigFreq + i*0.9) * 14;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.restore();

      ctx.fillStyle="rgba(255,255,255,.85)";
      roundRect(x+o.w*0.22,y+o.h*0.18,o.w*0.52,o.h*0.72,18); ctx.fill();
      ctx.fillStyle="rgba(255,190,40,.95)";
      roundRect(x+o.w*0.24,y+o.h*0.34,o.w*0.48,o.h*0.54,16); ctx.fill();
      ctx.strokeStyle="rgba(255,255,255,.85)";
      ctx.lineWidth=10;
      ctx.beginPath();
      ctx.arc(x+o.w*0.78,y+o.h*0.55,o.w*0.12,-Math.PI/2,Math.PI/2);
      ctx.stroke();
    } else if(o.kind==="flower"){
      const cx=x+o.w*0.52, cy=y+o.h*0.48;
      ctx.save(); ctx.translate(cx,cy);
      ctx.fillStyle="rgba(255,200,0,.95)";
      for(let i=0;i<6;i++){
        ctx.rotate(Math.PI/3);
        ctx.beginPath(); ctx.ellipse(0,-o.h*0.22,o.w*0.12,o.h*0.18,0,0,Math.PI*2); ctx.fill();
      }
      ctx.fillStyle="rgba(255,80,80,.95)";
      ctx.beginPath(); ctx.arc(0,0,Math.min(o.w,o.h)*0.13,0,Math.PI*2); ctx.fill();
      ctx.restore();
      ctx.fillStyle="rgba(30,130,70,.95)";
      ctx.fillRect(x+o.w*0.48,y+o.h*0.40,o.w*0.06,o.h*0.60);
    } else if(o.kind==="angel"){
      ctx.fillStyle="rgba(255,255,255,.92)";
      ctx.beginPath();
      ctx.ellipse(x+o.w*0.30,y+o.h*0.52,o.w*0.22,o.h*0.20,-0.4,0,Math.PI*2);
      ctx.ellipse(x+o.w*0.70,y+o.h*0.52,o.w*0.22,o.h*0.20,0.4,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle="rgba(255,230,120,.95)";
      ctx.lineWidth=6;
      ctx.beginPath(); ctx.ellipse(x+o.w*0.50,y+o.h*0.18,o.w*0.18,o.h*0.10,0,0,Math.PI*2); ctx.stroke();
      drawPerson(x,y,o.w,o.h,"rgba(250,225,95,1)","rgba(240,240,255,1)","rgba(255,225,200,1)",false,false);
    } else if(o.kind==="girl_piano"){
      drawPerson(x,y,o.w*0.55,o.h,"rgba(250,220,80,1)","rgba(250,120,70,1)","rgba(255,225,200,1)",false,false);
      ctx.fillStyle="rgba(20,20,25,1)";
      roundRect(x+o.w*0.50,y+o.h*0.60,o.w*0.48,o.h*0.30,14); ctx.fill();
    } else if(o.kind==="man_laptop"){
      drawPerson(x,y,o.w*0.55,o.h,"rgba(40,25,15,1)","rgba(60,160,120,1)","rgba(255,220,195,1)",false,false);
      ctx.fillStyle="rgba(30,30,35,1)";
      roundRect(x+o.w*0.52,y+o.h*0.64,o.w*0.44,o.h*0.22,12); ctx.fill();
    } else if(o.kind==="tall_black_girl"){
      drawPerson(x,y,o.w,o.h,"rgba(10,10,10,1)","rgba(40,40,80,1)","rgba(145,95,70,1)",false,false);
    } else if(o.kind==="slanted_girl"){
      drawPerson(x,y,o.w,o.h,"rgba(25,20,15,1)","rgba(230,90,150,1)","rgba(255,225,205,1)",false,true);
    } else if(o.kind==="blond_mustache_man"){
      drawPerson(x,y,o.w,o.h,"rgba(245,215,60,1)","rgba(80,120,200,1)","rgba(255,225,200,1)",true,false);
    } else if(o.kind==="hairy_man"){
      drawPerson(x,y,o.w,o.h,"rgba(40,25,15,1)","rgba(60,160,120,1)","rgba(255,220,195,1)",false,false);
    } else if(o.kind==="bald_mustache_man"){
      drawPerson(x,y,o.w,o.h,"rgba(0,0,0,0)","rgba(140,80,170,1)","rgba(255,225,200,1)",true,false);
    } else if(o.kind==="blonde_girl"){
      drawPerson(x,y,o.w,o.h,"rgba(250,220,80,1)","rgba(250,120,70,1)","rgba(255,225,200,1)",false,false);
    }

    drawNameBig(x+o.w/2, y, o.name);
  }

  function drawFX(){
    for(const f of fx){
      const a = clamp(1 - f.t/f.life, 0, 1);
      const sx=f.x-cam.x, sy=f.y-cam.y;

      ctx.save();
      ctx.globalAlpha=0.95*a;
      ctx.fillStyle="rgba(0,0,0,.42)";
      roundRect(sx-80, sy-90, 160, 50, 16); ctx.fill();
      ctx.fillStyle="#fff";
      ctx.font="1000 30px system-ui";
      ctx.fillText("BOOM", sx-54, sy-56);
      ctx.restore();

      for(const p of f.sparks){
        const px=sx+p.x, py=sy+p.y;
        const hot=clamp(1 - f.t/f.life, 0, 1);
        ctx.save();
        ctx.globalAlpha=0.85*a;
        ctx.fillStyle=`rgba(255,${Math.floor(150+hot*90)},${Math.floor(30+hot*50)},1)`;
        ctx.beginPath(); ctx.arc(px,py,p.r,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }
  }

  function drawPlayer(){
    const w=pW(), h=pH();
    const x=player.x-cam.x, y=player.y-cam.y;

    if(player.iFrames>0 && (Math.floor(performance.now()/80)%2===0)) return;

    ctx.fillStyle="rgba(0,0,0,.18)";
    ctx.beginPath(); ctx.ellipse(x+w/2, y+h+10, w*0.55, 10, 0, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle="rgba(30,40,55,1)";
    roundRect(x+3, y+Math.max(18,h*0.28), w-6, h*0.72, 18); ctx.fill();

    ctx.fillStyle="rgba(245,245,245,1)";
    roundRect(x+4, y+Math.max(30,h*0.55), w-8, h*0.45, 18); ctx.fill();

    ctx.fillStyle="rgba(255,225,200,1)";
    ctx.beginPath(); ctx.ellipse(x+w/2, y+22, w*0.22, h*0.18, 0, 0, Math.PI*2); ctx.fill();

    ctx.strokeStyle="rgba(20,20,20,.95)"; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(x+w/2-6, y+24); ctx.lineTo(x+w/2-20, y+26); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x+w/2+6, y+24); ctx.lineTo(x+w/2+20, y+26); ctx.stroke();

    ctx.fillStyle="rgba(50,170,90,1)";
    roundRect(x-3, y+6, w+6, h*0.14, 16); ctx.fill();
    ctx.fillStyle="rgba(40,140,75,1)";
    roundRect(x+4, y-10, w-8, h*0.11, 16); ctx.fill();
  }

  function drawCastle(){
    const sx=castle.x-cam.x;
    const sy=(MAP_H-2)*TILE - castle.h;

    ctx.fillStyle="rgba(170,150,120,1)";
    roundRect(sx,sy,castle.w,castle.h,22); ctx.fill();

    ctx.fillStyle="rgba(0,0,0,.45)";
    roundRect(sx+castle.w*0.12, sy+16, castle.w*0.76, 52, 14); ctx.fill();
    ctx.fillStyle="#fff";
    ctx.font="1000 26px system-ui";
    ctx.fillText("Дом Алёны", sx+castle.w*0.30, sy+52);

    const px=pole.x-cam.x;
    ctx.strokeStyle="rgba(40,40,40,.9)";
    ctx.lineWidth=8;
    ctx.beginPath();
    ctx.moveTo(px, pole.topY - cam.y);
    ctx.lineTo(px, pole.bottomY - cam.y);
    ctx.stroke();

    ctx.fillStyle="rgba(240,60,60,.95)";
    ctx.beginPath();
    ctx.moveTo(px, pole.topY - cam.y + 22);
    ctx.lineTo(px+64, pole.topY - cam.y + 40);
    ctx.lineTo(px, pole.topY - cam.y + 58);
    ctx.closePath();
    ctx.fill();

    if(cutscene || gameOver){
      const ax = sx+castle.w*0.86, ay = sy+castle.h*0.88;
      ctx.fillStyle="rgba(250,225,95,1)";
      ctx.beginPath(); ctx.ellipse(ax, ay-150, 74, 54, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle="rgba(255,225,200,1)";
      ctx.beginPath(); ctx.ellipse(ax, ay-138, 30, 30, 0, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle="rgba(25,25,25,.95)";
      ctx.lineWidth=4;
      ctx.beginPath(); ctx.moveTo(ax-16, ay-140); ctx.lineTo(ax-6, ay-140); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ax+6, ay-140); ctx.lineTo(ax+16, ay-140); ctx.stroke();
      ctx.fillStyle="rgba(255,255,255,.97)";
      roundRect(ax-60, ay-106, 120, 150, 30); ctx.fill();
      ctx.fillStyle="rgba(255,210,60,1)";
      roundRect(ax-46, ay-32, 92, 16, 12); ctx.fill();
    }
  }

  // ----- Physics + game loop -----
  function update(dt){
    if(gameOver) return;

    if(player.iFrames>0) player.iFrames=Math.max(0, player.iFrames-dt);

    const vw = canvas.clientWidth;
    const vh = canvas.clientHeight;

    if(cutscene){
      player.vx = 240;
      player.vy += GRAV*dt;
      collide(dt);

      cam.x = clamp(player.x + pW()/2 - vw*0.40, 0, WORLD_W - vw);
      cam.y = 0;

      if(player.x > castle.x - 140){
        player.vx=0;
        gameOver=true;
      }
      updateFX(dt);
      hudText.textContent = `Счёт: ${score} • ${hearts()}`;
      return;
    }

    time += dt;

    // spawn
    if(!flagTriggered && player.x < STOP_OBS_X){
      spawnTimer += dt;
      if(spawnTimer >= 3.0){
        spawnTimer = 0;
        spawnWave(time);
      }
      updateObstacles(dt);
    }

    // control
    applyMovement(dt);

    // gravity
    player.vy += GRAV*dt;
    collide(dt);

    cam.x = clamp(player.x + pW()/2 - vw*0.40, 0, WORLD_W - vw);
    cam.y = 0;

    handleHits();
    updateFX(dt);

    if(!flagTriggered && (player.x + pW() >= FLAG_LINE_X)){
      flagTriggered=true;
      overlay.style.display="flex";
      finalScore.textContent = `Счёт: ${score}`;
      cutscene=true;
    }

    hudText.textContent = `Счёт: ${score} • ${hearts()}`;
  }

  function draw(){
    // draw in CSS pixels (we already set ctx transform to dpr)
    const vw = canvas.clientWidth;
    const vh = canvas.clientHeight;

    ctx.clearRect(0,0,vw,vh);

    drawBackground(vw,vh);
    drawTiles(vw,vh);

    // landmarks
    drawLandmarks();

    // flag line
    drawFlagLine(vw,vh);

    // obstacles
    for(const o of obstacles) drawObstacle(o);

    drawFX();
    drawCastle();
    drawPlayer();
  }

  function resetGame(){
    score=0; time=0; spawnTimer=0; spawnIndex=0;
    flagTriggered=false; cutscene=false; gameOver=false;
    overlay.style.display="none";

    player.x=70; player.y=0; player.vx=0; player.vy=0; player.onGround=false;
    player.stage=0; player.lives=3; player.iFrames=0;

    obstacles.length=0;
    activeNames.clear();
    lastSpawn.clear();
    fx.length=0;
    cam.x=0; cam.y=0;

    hudText.textContent = `Счёт: 0 • ${hearts()}`;
  }

  // Collision helpers need these
  function collideAndClamp(dt){ collide(dt); }

  // fixed missing reference (collide uses resetGame already)
  // Main loop
  let last=performance.now();
  function loop(now){
    const dt = Math.min(0.033,(now-last)/1000);
    last=now;
    if(running){
      update(dt);
      draw();
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ----- Start / Back / Restart -----
  function startGame(){
    menu.style.display="none";
    gameWrap.style.display="flex";
    running=true;
    resizeCanvas();
    resetGame();
  }

  startText.addEventListener("click", startGame);

  backBtn.addEventListener("click", ()=>{
    running=false;
    gameWrap.style.display="none";
    menu.style.display="flex";
  });

  restartBtn.addEventListener("click", resetGame);

  // initial
  // Wait a tick so layout exists
  setTimeout(resizeCanvas, 50);

})();
</script>
</body>
</html>
